-- blank_node // Autogenerated from class: blank node
--   blank_node.id // 
-- class_node // Autogenerated from class: class node
--   class_node.id // 
-- count_of_instantiated_classes // Autogenerated from class: count of instantiated classes
--   count_of_instantiated_classes.element // 
--   count_of_instantiated_classes.number_of_usages // 
-- count_of_predicates // Autogenerated from class: count of predicates
--   count_of_predicates.element // 
--   count_of_predicates.number_of_usages // 
-- iri_node // Autogenerated from class: iri node
--   iri_node.id // 
-- match // Autogenerated from class: match
--   match.subject_id // 
--   match.subject_label // 
--   match.subject_source // 
--   match.subject_match_field // 
--   match.subject_preprocessing // 
--   match.object_id // 
--   match.object_label // 
--   match.object_source // 
--   match.object_match_field // 
--   match.object_preprocessing // 
--   match.match_string // 
-- named_individual_node // Autogenerated from class: named individual node
--   named_individual_node.id // 
-- node // Autogenerated from class: node
--   node.id // 
-- node_to_node_statement // A statement where object is non-null and value is not populated
--   node_to_node_statement.stanza // 
--   node_to_node_statement.subject // 
--   node_to_node_statement.predicate // 
--   node_to_node_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   node_to_node_statement.datatype // 
--   node_to_node_statement.language // 
--   node_to_node_statement.object // 
-- node_to_value_statement // A statement where value is non-null and object is not populated
--   node_to_value_statement.stanza // 
--   node_to_value_statement.subject // 
--   node_to_value_statement.predicate // 
--   node_to_value_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   node_to_value_statement.datatype // 
--   node_to_value_statement.language // 
--   node_to_value_statement.value // 
-- prefix // Maps CURIEs to URIs
--   prefix.prefix // 
--   prefix.base // 
-- processed_statement // Autogenerated from class: processed statement
--   processed_statement.subject // 
--   processed_statement.predicate // 
--   processed_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   processed_statement.transformation_predicate // 
--   processed_statement.transformed_value // 
-- property_node // Note this only directly classifies nodes asserted to be rdf:Properties
--   property_node.id // 
-- rdf_first_statement // A statement that connects a list to its first element. This is a low-level triple, it is unlikely you need to use this directly. It is used to define rdf_list_member_statement, which is more useful
--   rdf_first_statement.stanza // 
--   rdf_first_statement.predicate // 
--   rdf_first_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   rdf_first_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdf_first_statement.datatype // 
--   rdf_first_statement.language // 
--   rdf_first_statement.subject // The rdf:List to which the statement applies
-- rdf_level_summary_statistic // Autogenerated from class: rdf level summary statistic
--   rdf_level_summary_statistic.element // 
--   rdf_level_summary_statistic.number_of_usages // 
-- rdf_list_member_statement // Autogenerated from class: rdf list member statement
--   rdf_list_member_statement.stanza // 
--   rdf_list_member_statement.predicate // 
--   rdf_list_member_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   rdf_list_member_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdf_list_member_statement.datatype // 
--   rdf_list_member_statement.language // 
--   rdf_list_member_statement.subject // The rdf:List to which the statement applies
-- rdf_list_node // A node representing an RDF list
--   rdf_list_node.id // 
-- rdf_list_statement // A statement that is used to represent aspects of RDF lists
--   rdf_list_statement.stanza // 
--   rdf_list_statement.predicate // 
--   rdf_list_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   rdf_list_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdf_list_statement.datatype // 
--   rdf_list_statement.language // 
--   rdf_list_statement.subject // The rdf:List to which the statement applies
-- rdf_rest_statement // A statement that connects a list to its remaining elements. This is a low-level triple, it is unlikely you need to use this directly. It is used to define rdf_list_member_statement, which is more useful
--   rdf_rest_statement.stanza // 
--   rdf_rest_statement.predicate // 
--   rdf_rest_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   rdf_rest_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdf_rest_statement.datatype // 
--   rdf_rest_statement.language // 
--   rdf_rest_statement.subject // The rdf:List to which the statement applies
-- rdf_rest_transitive_statement // Autogenerated from class: rdf rest transitive statement
--   rdf_rest_transitive_statement.stanza // 
--   rdf_rest_transitive_statement.predicate // 
--   rdf_rest_transitive_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   rdf_rest_transitive_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdf_rest_transitive_statement.datatype // 
--   rdf_rest_transitive_statement.language // 
--   rdf_rest_transitive_statement.subject // The rdf:List to which the statement applies
-- rdf_type_statement // A statement that indicates the asserted type of the subject entity
--   rdf_type_statement.stanza // 
--   rdf_type_statement.subject // 
--   rdf_type_statement.predicate // 
--   rdf_type_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdf_type_statement.datatype // 
--   rdf_type_statement.language // 
--   rdf_type_statement.object // The entity type
-- rdfs_domain_statement // Autogenerated from class: rdfs domain statement
--   rdfs_domain_statement.stanza // 
--   rdfs_domain_statement.subject // 
--   rdfs_domain_statement.predicate // 
--   rdfs_domain_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdfs_domain_statement.datatype // 
--   rdfs_domain_statement.language // 
--   rdfs_domain_statement.object // 
-- rdfs_label_statement // Autogenerated from class: rdfs label statement
--   rdfs_label_statement.stanza // 
--   rdfs_label_statement.subject // 
--   rdfs_label_statement.predicate // 
--   rdfs_label_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   rdfs_label_statement.datatype // 
--   rdfs_label_statement.language // 
--   rdfs_label_statement.value // The label value
-- rdfs_range_statement // Autogenerated from class: rdfs range statement
--   rdfs_range_statement.stanza // 
--   rdfs_range_statement.subject // 
--   rdfs_range_statement.predicate // 
--   rdfs_range_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdfs_range_statement.datatype // 
--   rdfs_range_statement.language // 
--   rdfs_range_statement.object // 
-- rdfs_subclass_of_named_statement // Autogenerated from class: rdfs subclass of named statement
--   rdfs_subclass_of_named_statement.stanza // 
--   rdfs_subclass_of_named_statement.predicate // 
--   rdfs_subclass_of_named_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdfs_subclass_of_named_statement.datatype // 
--   rdfs_subclass_of_named_statement.language // 
--   rdfs_subclass_of_named_statement.subject // The subclass element of the triple
--   rdfs_subclass_of_named_statement.object // The superclass element of the triple
-- rdfs_subclass_of_statement // Autogenerated from class: rdfs subclass of statement
--   rdfs_subclass_of_statement.stanza // 
--   rdfs_subclass_of_statement.predicate // 
--   rdfs_subclass_of_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdfs_subclass_of_statement.datatype // 
--   rdfs_subclass_of_statement.language // 
--   rdfs_subclass_of_statement.subject // The subclass element of the triple
--   rdfs_subclass_of_statement.object // The superclass element of the triple
-- rdfs_subproperty_of_statement // Autogenerated from class: rdfs subproperty of statement
--   rdfs_subproperty_of_statement.stanza // 
--   rdfs_subproperty_of_statement.predicate // 
--   rdfs_subproperty_of_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdfs_subproperty_of_statement.datatype // 
--   rdfs_subproperty_of_statement.language // 
--   rdfs_subproperty_of_statement.subject // The subproperty element of the triple
--   rdfs_subproperty_of_statement.object // The superproperty element of the triple
-- statements // Represents an RDF triple
--   statements.stanza // 
--   statements.subject // 
--   statements.predicate // 
--   statements.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   statements.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   statements.datatype // 
--   statements.language // 
-- subject_prefix // Autogenerated from class: subject prefix
--   subject_prefix.subject // 
--   subject_prefix.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
-- textual_transformation // Autogenerated from class: textual transformation
--   textual_transformation.subject // 
--   textual_transformation.predicate // 
--   textual_transformation.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion


CREATE TABLE blank_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE class_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE count_of_instantiated_classes (
	element TEXT, 
	number_of_usages INTEGER
);

CREATE TABLE count_of_predicates (
	element TEXT, 
	number_of_usages INTEGER
);

CREATE TABLE iri_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE match (
	subject_id TEXT, 
	subject_label TEXT, 
	subject_source TEXT, 
	subject_match_field TEXT, 
	subject_preprocessing TEXT, 
	object_id TEXT, 
	object_label TEXT, 
	object_source TEXT, 
	object_match_field TEXT, 
	object_preprocessing TEXT, 
	match_string TEXT
);

CREATE TABLE named_individual_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE node_to_node_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE node_to_value_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE prefix (
	prefix TEXT, 
	base TEXT
);

CREATE TABLE processed_statement (
	subject TEXT, 
	predicate TEXT, 
	value TEXT, 
	transformation_predicate TEXT, 
	transformed_value TEXT
);

CREATE TABLE property_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE rdf_first_statement (
	stanza TEXT, 
	predicate TEXT, 
	object TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT
);

CREATE TABLE rdf_level_summary_statistic (
	element TEXT, 
	number_of_usages INTEGER
);

CREATE TABLE rdf_list_member_statement (
	stanza TEXT, 
	predicate TEXT, 
	object TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT
);

CREATE TABLE rdf_list_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE rdf_list_statement (
	stanza TEXT, 
	predicate TEXT, 
	object TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT
);

CREATE TABLE rdf_rest_statement (
	stanza TEXT, 
	predicate TEXT, 
	object TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT
);

CREATE TABLE rdf_rest_transitive_statement (
	stanza TEXT, 
	predicate TEXT, 
	object TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT
);

CREATE TABLE rdf_type_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE rdfs_domain_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE rdfs_label_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE rdfs_range_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE rdfs_subclass_of_named_statement (
	stanza TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE rdfs_subclass_of_statement (
	stanza TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE rdfs_subproperty_of_statement (
	stanza TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE statements (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT
);

CREATE TABLE subject_prefix (
	subject TEXT, 
	value TEXT
);

CREATE TABLE textual_transformation (
	subject TEXT, 
	predicate TEXT, 
	value TEXT
);

-- ** REWRITE TABLES AS VIEWS **
-- SCHEMA: https://w3id.org/semsql/omo

DROP TABLE subject_prefix;
CREATE VIEW subject_prefix AS SELECT DISTINCT s.subject, prefix.prefix AS value FROM prefix, statements AS s WHERE INSTR(s.subject,prefix || ':')=1;

DROP TABLE processed_statement;
CREATE VIEW processed_statement AS SELECT s.*, t.predicate AS transformation_predicate, t.value AS transformed_value
  FROM statements AS s JOIN textual_transformation AS t ON(s.value=t.subject)
  WHERE datatype != 'xsd:boolean';

DROP TABLE match;
CREATE VIEW match AS SELECT
   s1.subject AS subject_id,
   s1l.value AS subject_label,
   s1.predicate AS subject_match_field,
   s1p.value AS subject_source,
   s1.transformation_predicate AS subject_preprocessing,
   s2.subject AS object_id,
   s2l.value AS object_label,
   s2.predicate AS object_match_field,
   s2p.value AS object_source,
   s2.transformation_predicate AS object_preprocessing,
   s1.transformed_value AS match_field
  FROM
    processed_statement AS s1
    JOIN processed_statement AS s2 ON (s1.transformed_value = s2.transformed_value)
    JOIN rdfs_label_statement AS s1l ON (s1.subject=s1l.subject)
    JOIN rdfs_label_statement AS s2l ON (s2.subject=s2l.subject)
    JOIN subject_prefix AS s1p ON (s1.subject=s1p.subject)
    JOIN subject_prefix AS s2p ON (s2.subject=s2p.subject)
    WHERE s1.subject != s2.subject;

DROP TABLE node_to_node_statement;
CREATE VIEW node_to_node_statement AS SELECT * FROM statements WHERE object IS NOT NULL;

DROP TABLE node_to_value_statement;
CREATE VIEW node_to_value_statement AS SELECT * FROM statements WHERE value IS NOT NULL;

DROP TABLE rdf_type_statement;
CREATE VIEW rdf_type_statement AS SELECT * FROM statements WHERE predicate='rdf:type';

DROP TABLE rdfs_subclass_of_statement;
CREATE VIEW rdfs_subclass_of_statement AS SELECT * FROM statements WHERE predicate='rdfs:subClassOf';

DROP TABLE rdfs_subclass_of_named_statement;
CREATE VIEW rdfs_subclass_of_named_statement AS SELECT * FROM rdfs_subclass_of_statement WHERE object NOT LIKE '_:%';

DROP TABLE rdfs_subproperty_of_statement;
CREATE VIEW rdfs_subproperty_of_statement AS SELECT * FROM statements WHERE predicate='rdfs:subPropertyOf';

DROP TABLE rdfs_label_statement;
CREATE VIEW rdfs_label_statement AS SELECT * FROM statements WHERE predicate='rdfs:label';

DROP TABLE rdfs_domain_statement;
CREATE VIEW rdfs_domain_statement AS SELECT * FROM statements WHERE predicate='rdfs:domain';

DROP TABLE rdfs_range_statement;
CREATE VIEW rdfs_range_statement AS SELECT * FROM statements WHERE predicate='rdfs:range';

DROP TABLE rdf_first_statement;
CREATE VIEW rdf_first_statement AS SELECT * FROM statements WHERE predicate='rdf:first';

DROP TABLE rdf_rest_statement;
CREATE VIEW rdf_rest_statement AS SELECT * FROM statements WHERE predicate='rdf:rest';

DROP TABLE rdf_rest_transitive_statement;
CREATE VIEW rdf_rest_transitive_statement AS WITH RECURSIVE rdf_rest_transitive_statement
             (
                   subject, object
             )
             AS
             (SELECT subject, object
                FROM rdf_rest_statement
               UNION ALL
              SELECT
                   rest.subject, rest_t.object
                FROM rdf_rest_statement AS rest
                JOIN rdf_rest_transitive_statement AS rest_t
                  ON rest.object = rest_t.subject
             )
          SELECT * FROM rdf_rest_transitive_statement;

DROP TABLE rdf_list_member_statement;
CREATE VIEW rdf_list_member_statement AS SELECT
     rest_t.subject,
     f.object
    FROM rdf_rest_transitive_statement AS rest_t JOIN rdf_first_statement AS f ON (rest_t.object = f.subject)
    UNION
    SELECT subject,object FROM rdf_first_statement;

DROP TABLE node;
CREATE VIEW node AS SELECT distinct(subject) AS id FROM statements UNION SELECT distinct(object) AS id FROM statements WHERE datatype IS NOT NULL;

DROP TABLE blank_node;
CREATE VIEW blank_node AS SELECT * FROM node WHERE id LIKE '_:%';

DROP TABLE rdf_list_node;
CREATE VIEW rdf_list_node AS SELECT distinct subject AS id from rdf_type_statement WHERE object = 'rdf:List';

DROP TABLE iri_node;
CREATE VIEW iri_node AS SELECT * FROM node WHERE id NOT LIKE '_:%';

DROP TABLE class_node;
CREATE VIEW class_node AS SELECT distinct subject AS id from rdf_type_statement WHERE object = 'owl:Class';

DROP TABLE property_node;
CREATE VIEW property_node AS SELECT distinct subject AS id from rdf_type_statement WHERE object = 'owl:Property';

DROP TABLE named_individual_node;
CREATE VIEW named_individual_node AS SELECT distinct subject AS id from rdf_type_statement WHERE object = 'owl:NamedIndividual';

DROP TABLE count_of_predicates;
CREATE VIEW count_of_predicates AS SELECT predicate AS element, count(*) AS number_of_usages FROM statements GROUP BY predicate ORDER BY number_of_usages DESC;

DROP TABLE count_of_instantiated_classes;
CREATE VIEW count_of_instantiated_classes AS SELECT object AS element, count(*) AS number_of_usages FROM rdf_type_statement GROUP BY element ORDER BY number_of_usages DESC;
