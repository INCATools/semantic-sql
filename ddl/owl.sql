-- annotation_property_node // Autogenerated from class: annotation property node
--   annotation_property_node.id // 
-- anonymous_class_expression // Autogenerated from class: anonymous class expression
--   anonymous_class_expression.id // 
-- anonymous_expression // Autogenerated from class: anonymous expression
--   anonymous_expression.id // 
-- anonymous_individual_expression // Autogenerated from class: anonymous individual expression
--   anonymous_individual_expression.id // 
-- anonymous_property_expression // Autogenerated from class: anonymous property expression
--   anonymous_property_expression.id // 
-- blank_node // Autogenerated from class: blank node
--   blank_node.id // 
-- class_node // Autogenerated from class: class node
--   class_node.id // 
-- count_of_instantiated_classes // Autogenerated from class: count of instantiated classes
--   count_of_instantiated_classes.element // 
--   count_of_instantiated_classes.number_of_usages // 
-- count_of_predicates // Autogenerated from class: count of predicates
--   count_of_predicates.element // 
--   count_of_predicates.number_of_usages // 
-- iri_node // Autogenerated from class: iri node
--   iri_node.id // 
-- named_individual_node // Autogenerated from class: named individual node
--   named_individual_node.id // 
-- node // Autogenerated from class: node
--   node.id // 
-- node_to_node_statement // A statement where object is non-null and value is not populated
--   node_to_node_statement.stanza // 
--   node_to_node_statement.subject // 
--   node_to_node_statement.predicate // 
--   node_to_node_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   node_to_node_statement.datatype // 
--   node_to_node_statement.language // 
--   node_to_node_statement.object // 
-- node_to_value_statement // A statement where value is non-null and object is not populated
--   node_to_value_statement.stanza // 
--   node_to_value_statement.subject // 
--   node_to_value_statement.predicate // 
--   node_to_value_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   node_to_value_statement.datatype // 
--   node_to_value_statement.language // 
--   node_to_value_statement.value // 
-- object_property_node // Autogenerated from class: object property node
--   object_property_node.id // 
-- ontology_node // A node representing an ontology
--   ontology_node.id // 
-- owl_all_values_from // Autogenerated from class: owl all values from
--   owl_all_values_from.on_property // 
--   owl_all_values_from.filler // 
--   owl_all_values_from.id // the id of the restriction
-- owl_disjoint_class_statement // Autogenerated from class: owl disjoint class statement
--   owl_disjoint_class_statement.stanza // 
--   owl_disjoint_class_statement.predicate // 
--   owl_disjoint_class_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   owl_disjoint_class_statement.datatype // 
--   owl_disjoint_class_statement.language // 
--   owl_disjoint_class_statement.subject // One of the two classes that are disjoint. No significance to subject vs object
--   owl_disjoint_class_statement.object // One of the two classes that are disjoint. No significance to subject vs object
-- owl_equivalent_class_statement // Autogenerated from class: owl equivalent class statement
--   owl_equivalent_class_statement.stanza // 
--   owl_equivalent_class_statement.predicate // 
--   owl_equivalent_class_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   owl_equivalent_class_statement.datatype // 
--   owl_equivalent_class_statement.language // 
--   owl_equivalent_class_statement.subject // One of the two classes that are equivalent. No significance to subject vs object
--   owl_equivalent_class_statement.object // One of the two classes that are equivalent. No significance to subject vs object
-- owl_equivalent_to_intersection_member // Composition of OwlEquivalentClass, OwlIntersectionOf, and RdfListMember; C = X1 and ... and Xn
--   owl_equivalent_to_intersection_member.subject // the defined class
--   owl_equivalent_to_intersection_member.object // a class expression that forms the defining expression
-- owl_restriction // Autogenerated from class: owl restriction
--   owl_restriction.on_property // 
--   owl_restriction.filler // 
--   owl_restriction.id // the id of the restriction
-- owl_some_values_from // Autogenerated from class: owl some values from
--   owl_some_values_from.on_property // 
--   owl_some_values_from.filler // 
--   owl_some_values_from.id // the id of the restriction
-- owl_subclass_of_some_values_from // Composition of subClassOf and SomeValuesFrom
--   owl_subclass_of_some_values_from.subject // the class C in the axiom C subClassOf P some D
--   owl_subclass_of_some_values_from.predicate // the predicate P in the axiom C subClassOf P some D
--   owl_subclass_of_some_values_from.object // the class D in the axiom C subClassOf P some D
-- prefix // Maps CURIEs to URIs
--   prefix.prefix // 
--   prefix.base // 
-- property_node // Autogenerated from class: property node
--   property_node.id // 
-- rdf_first_statement // A statement that connects a list to its first element. This is a low-level triple, it is unlikely you need to use this directly. It is used to define rdf_list_member_statement, which is more useful
--   rdf_first_statement.stanza // 
--   rdf_first_statement.predicate // 
--   rdf_first_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   rdf_first_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdf_first_statement.datatype // 
--   rdf_first_statement.language // 
--   rdf_first_statement.subject // The rdf:List to which the statement applies
-- rdf_level_summary_statistic // Autogenerated from class: rdf level summary statistic
--   rdf_level_summary_statistic.element // 
--   rdf_level_summary_statistic.number_of_usages // 
-- rdf_list_member_statement // Autogenerated from class: rdf list member statement
--   rdf_list_member_statement.stanza // 
--   rdf_list_member_statement.predicate // 
--   rdf_list_member_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   rdf_list_member_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdf_list_member_statement.datatype // 
--   rdf_list_member_statement.language // 
--   rdf_list_member_statement.subject // The rdf:List to which the statement applies
-- rdf_list_node // A node representing an RDF list
--   rdf_list_node.id // 
-- rdf_list_statement // A statement that is used to represent aspects of RDF lists
--   rdf_list_statement.stanza // 
--   rdf_list_statement.predicate // 
--   rdf_list_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   rdf_list_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdf_list_statement.datatype // 
--   rdf_list_statement.language // 
--   rdf_list_statement.subject // The rdf:List to which the statement applies
-- rdf_rest_statement // A statement that connects a list to its remaining elements. This is a low-level triple, it is unlikely you need to use this directly. It is used to define rdf_list_member_statement, which is more useful
--   rdf_rest_statement.stanza // 
--   rdf_rest_statement.predicate // 
--   rdf_rest_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   rdf_rest_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdf_rest_statement.datatype // 
--   rdf_rest_statement.language // 
--   rdf_rest_statement.subject // The rdf:List to which the statement applies
-- rdf_rest_transitive_statement // Autogenerated from class: rdf rest transitive statement
--   rdf_rest_transitive_statement.stanza // 
--   rdf_rest_transitive_statement.predicate // 
--   rdf_rest_transitive_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   rdf_rest_transitive_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdf_rest_transitive_statement.datatype // 
--   rdf_rest_transitive_statement.language // 
--   rdf_rest_transitive_statement.subject // The rdf:List to which the statement applies
-- rdf_type_statement // A statement that indicates the asserted type of the subject entity
--   rdf_type_statement.stanza // 
--   rdf_type_statement.subject // 
--   rdf_type_statement.predicate // 
--   rdf_type_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdf_type_statement.datatype // 
--   rdf_type_statement.language // 
--   rdf_type_statement.object // The entity type
-- rdfs_label_statement // Autogenerated from class: rdfs label statement
--   rdfs_label_statement.stanza // 
--   rdfs_label_statement.subject // 
--   rdfs_label_statement.predicate // 
--   rdfs_label_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   rdfs_label_statement.datatype // 
--   rdfs_label_statement.language // 
--   rdfs_label_statement.value // 
-- rdfs_subclass_of_statement // Autogenerated from class: rdfs subclass of statement
--   rdfs_subclass_of_statement.stanza // 
--   rdfs_subclass_of_statement.predicate // 
--   rdfs_subclass_of_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdfs_subclass_of_statement.datatype // 
--   rdfs_subclass_of_statement.language // 
--   rdfs_subclass_of_statement.subject // The subclass element of the triple
--   rdfs_subclass_of_statement.object // The superclass element of the triple
-- statements // Represents an RDF triple
--   statements.stanza // 
--   statements.subject // 
--   statements.predicate // 
--   statements.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   statements.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   statements.datatype // 
--   statements.language // 
-- transitive_property_node // Autogenerated from class: transitive property node
--   transitive_property_node.id // 


CREATE TABLE annotation_property_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE anonymous_class_expression (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE anonymous_expression (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE anonymous_individual_expression (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE anonymous_property_expression (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE blank_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE class_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE count_of_instantiated_classes (
	element TEXT, 
	number_of_usages INTEGER
);

CREATE TABLE count_of_predicates (
	element TEXT, 
	number_of_usages INTEGER
);

CREATE TABLE iri_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE named_individual_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE node_to_node_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE node_to_value_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE object_property_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE ontology_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE owl_all_values_from (
	on_property TEXT, 
	filler TEXT, 
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE owl_disjoint_class_statement (
	stanza TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT, 
	object TEXT
);

CREATE TABLE owl_equivalent_class_statement (
	stanza TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT, 
	object TEXT
);

CREATE TABLE owl_equivalent_to_intersection_member (
	subject TEXT, 
	object TEXT
);

CREATE TABLE owl_restriction (
	on_property TEXT, 
	filler TEXT, 
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE owl_some_values_from (
	on_property TEXT, 
	filler TEXT, 
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE owl_subclass_of_some_values_from (
	subject TEXT, 
	predicate TEXT, 
	object TEXT
);

CREATE TABLE prefix (
	prefix TEXT, 
	base TEXT
);

CREATE TABLE property_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE rdf_first_statement (
	stanza TEXT, 
	predicate TEXT, 
	object TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT
);

CREATE TABLE rdf_level_summary_statistic (
	element TEXT, 
	number_of_usages INTEGER
);

CREATE TABLE rdf_list_member_statement (
	stanza TEXT, 
	predicate TEXT, 
	object TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT
);

CREATE TABLE rdf_list_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE rdf_list_statement (
	stanza TEXT, 
	predicate TEXT, 
	object TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT
);

CREATE TABLE rdf_rest_statement (
	stanza TEXT, 
	predicate TEXT, 
	object TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT
);

CREATE TABLE rdf_rest_transitive_statement (
	stanza TEXT, 
	predicate TEXT, 
	object TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT
);

CREATE TABLE rdf_type_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE rdfs_label_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE rdfs_subclass_of_statement (
	stanza TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE statements (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT
);

CREATE TABLE transitive_property_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

-- ** REWRITE TABLES AS VIEWS **
-- SCHEMA: https://w3id.org/semsql/owl

DROP TABLE ontology_node;
CREATE VIEW ontology_node AS SELECT DISTINCT subject AS id FROM rdf_type_statement WHERE object='owl:Ontology';

DROP TABLE object_property_node;
CREATE VIEW object_property_node AS SELECT DISTINCT subject AS id FROM rdf_type_statement WHERE object='owl:ObjectProperty';

DROP TABLE transitive_property_node;
CREATE VIEW transitive_property_node AS SELECT DISTINCT subject AS id FROM rdf_type_statement WHERE object='owl:TransitiveProperty';

DROP TABLE annotation_property_node;
CREATE VIEW annotation_property_node AS SELECT DISTINCT subject AS id FROM rdf_type_statement WHERE object='owl:AnnotatonProperty';

DROP TABLE owl_equivalent_class_statement;
CREATE VIEW owl_equivalent_class_statement AS SELECT * FROM statements WHERE predicate='owl:equivalentClass';

DROP TABLE owl_disjoint_class_statement;
CREATE VIEW owl_disjoint_class_statement AS SELECT * FROM statements WHERE predicate='owl:disjointClass';

DROP TABLE owl_some_values_from;
CREATE VIEW owl_some_values_from AS SELECT onProperty.subject AS id,
            onProperty.object AS on_property,
            someValuesFrom.object AS filler
            FROM
       statements AS onProperty,
       statements AS someValuesFrom
     WHERE
       onProperty.predicate = 'owl:onProperty' AND
       onProperty.subject=someValuesFrom.subject AND
       someValuesFrom.predicate='owl:someValuesFrom';

DROP TABLE owl_all_values_from;
CREATE VIEW owl_all_values_from AS SELECT onProperty.subject AS id,
            onProperty.object AS on_property,
            someValuesFrom.object AS filler
            FROM
       statements AS onProperty,
       statements AS someValuesFrom
     WHERE
       onProperty.predicate = 'owl:onProperty' AND
       onProperty.subject=someValuesFrom.subject AND
       someValuesFrom.predicate='owl:allValuesFrom';

DROP TABLE owl_subclass_of_some_values_from;
CREATE VIEW owl_subclass_of_some_values_from AS SELECT subClassOf.stanza,
         subClassOf.subject,
         svf.on_property AS predicate,
         svf.filler AS object
         FROM
    statements AS subClassOf, 
    owl_some_values_from AS svf
  WHERE
    subClassOf.predicate = 'rdfs:subClassOf' AND
    svf.id=subClassOf.object;

DROP TABLE owl_equivalent_to_intersection_member;
CREATE VIEW owl_equivalent_to_intersection_member AS SELECT e.stanza,
           e.subject,
           m.object
           FROM
      owl_equivalent_class_statement AS e JOIN
      statements AS i ON (e.object=i.subject) JOIN
      rdf_list_member_statement AS m ON (i.object=m.subject)
    WHERE
      i.predicate = 'owl:intersectionOf';

DROP TABLE node_to_node_statement;
CREATE VIEW node_to_node_statement AS SELECT * FROM statements WHERE object IS NOT NULL;

DROP TABLE node_to_value_statement;
CREATE VIEW node_to_value_statement AS SELECT * FROM statements WHERE value IS NOT NULL;

DROP TABLE rdf_type_statement;
CREATE VIEW rdf_type_statement AS SELECT * FROM statements WHERE predicate='rdf:type';

DROP TABLE rdfs_subclass_of_statement;
CREATE VIEW rdfs_subclass_of_statement AS SELECT * FROM statements WHERE predicate='rdfs:subClassOf';

DROP TABLE rdfs_label_statement;
CREATE VIEW rdfs_label_statement AS SELECT * FROM statements WHERE predicate='rdfs:label';

DROP TABLE rdf_first_statement;
CREATE VIEW rdf_first_statement AS SELECT * FROM statements WHERE predicate='rdf:first';

DROP TABLE rdf_rest_statement;
CREATE VIEW rdf_rest_statement AS SELECT * FROM statements WHERE predicate='rdf:rest';

DROP TABLE rdf_rest_transitive_statement;
CREATE VIEW rdf_rest_transitive_statement AS WITH RECURSIVE rdf_rest_transitive_statement
             (
                   subject, object
             )
             AS
             (SELECT subject, object
                FROM rdf_rest_statement
               UNION ALL
              SELECT
                   rest.subject, rest_t.object
                FROM rdf_rest_statement AS rest
                JOIN rdf_rest_transitive_statement AS rest_t
                  ON rest.object = rest_t.subject
             )
          SELECT * FROM rdf_rest_transitive_statement;

DROP TABLE rdf_list_member_statement;
CREATE VIEW rdf_list_member_statement AS SELECT
     rest_t.subject,
     f.object
    FROM rdf_rest_transitive_statement AS rest_t JOIN rdf_first_statement AS f ON (rest_t.object = f.subject)
    UNION
    SELECT subject,object FROM rdf_first_statement;

DROP TABLE node;
CREATE VIEW node AS SELECT distinct(subject) AS id FROM statements UNION SELECT distinct(object) AS id FROM statements WHERE datatype IS NOT NULL;

DROP TABLE blank_node;
CREATE VIEW blank_node AS SELECT * FROM node WHERE id LIKE '_:%';

DROP TABLE rdf_list_node;
CREATE VIEW rdf_list_node AS SELECT distinct subject AS id from rdf_type_statement WHERE object = 'rdf:List';

DROP TABLE iri_node;
CREATE VIEW iri_node AS SELECT * FROM node WHERE id NOT LIKE '_:%';

DROP TABLE class_node;
CREATE VIEW class_node AS SELECT distinct subject AS id from rdf_type_statement WHERE object = 'owl:Class';

DROP TABLE named_individual_node;
CREATE VIEW named_individual_node AS SELECT distinct subject AS id from rdf_type_statement WHERE object = 'owl:NamedIndividual';

DROP TABLE count_of_predicates;
CREATE VIEW count_of_predicates AS SELECT predicate AS element, count(*) AS number_of_usages FROM statements GROUP BY predicate ORDER BY number_of_usages DESC;

DROP TABLE count_of_instantiated_classes;
CREATE VIEW count_of_instantiated_classes AS SELECT object AS element, count(*) AS number_of_usages FROM rdf_type_statement GROUP BY element ORDER BY number_of_usages DESC;
