-- all_problems // Autogenerated from class: all problems
--   all_problems.subject // The thing that is problematic
--   all_problems.predicate // The property of the thing that is problematic
--   all_problems.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
-- annotation_property_node // Autogenerated from class: annotation property node
--   annotation_property_node.id // 
-- anonymous_class_expression // Autogenerated from class: anonymous class expression
--   anonymous_class_expression.id // 
-- anonymous_expression // Autogenerated from class: anonymous expression
--   anonymous_expression.id // 
-- anonymous_individual_expression // Autogenerated from class: anonymous individual expression
--   anonymous_individual_expression.id // 
-- anonymous_property_expression // Autogenerated from class: anonymous property expression
--   anonymous_property_expression.id // 
-- blank_node // Autogenerated from class: blank node
--   blank_node.id // 
-- class_node // Autogenerated from class: class node
--   class_node.id // 
-- count_of_instantiated_classes // Autogenerated from class: count of instantiated classes
--   count_of_instantiated_classes.element // 
--   count_of_instantiated_classes.number_of_usages // 
-- count_of_predicates // Autogenerated from class: count of predicates
--   count_of_predicates.element // 
--   count_of_predicates.number_of_usages // 
-- edge // A relation graph edge that connects two entities by a predicate. Note an edge is distinct from a statement, in that an axiom such as A SubClassOf R some B is represented as multiple statements, but is a single relation graph edge
--   edge.subject // 
--   edge.predicate // 
--   edge.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
-- entailed_edge // A relation graph edge that is inferred
--   entailed_edge.subject // 
--   entailed_edge.predicate // 
--   entailed_edge.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
-- has_broad_match_statement // Autogenerated from class: has broad match statement
--   has_broad_match_statement.stanza // 
--   has_broad_match_statement.subject // 
--   has_broad_match_statement.predicate // 
--   has_broad_match_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   has_broad_match_statement.datatype // 
--   has_broad_match_statement.language // 
--   has_broad_match_statement.value // 
-- has_broad_synonym_statement // Autogenerated from class: has broad synonym statement
--   has_broad_synonym_statement.stanza // 
--   has_broad_synonym_statement.subject // 
--   has_broad_synonym_statement.predicate // 
--   has_broad_synonym_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   has_broad_synonym_statement.datatype // 
--   has_broad_synonym_statement.language // 
--   has_broad_synonym_statement.value // 
-- has_dbxref_statement // Autogenerated from class: has dbxref statement
--   has_dbxref_statement.stanza // 
--   has_dbxref_statement.subject // 
--   has_dbxref_statement.predicate // 
--   has_dbxref_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   has_dbxref_statement.datatype // 
--   has_dbxref_statement.language // 
--   has_dbxref_statement.value // 
-- has_exact_match_statement // Autogenerated from class: has exact match statement
--   has_exact_match_statement.stanza // 
--   has_exact_match_statement.subject // 
--   has_exact_match_statement.predicate // 
--   has_exact_match_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   has_exact_match_statement.datatype // 
--   has_exact_match_statement.language // 
--   has_exact_match_statement.value // 
-- has_exact_synonym_statement // Autogenerated from class: has exact synonym statement
--   has_exact_synonym_statement.stanza // 
--   has_exact_synonym_statement.subject // 
--   has_exact_synonym_statement.predicate // 
--   has_exact_synonym_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   has_exact_synonym_statement.datatype // 
--   has_exact_synonym_statement.language // 
--   has_exact_synonym_statement.value // 
-- has_mapping_statement // Autogenerated from class: has mapping statement
--   has_mapping_statement.stanza // 
--   has_mapping_statement.subject // 
--   has_mapping_statement.predicate // 
--   has_mapping_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   has_mapping_statement.datatype // 
--   has_mapping_statement.language // 
--   has_mapping_statement.value // 
-- has_match_statement // Autogenerated from class: has match statement
--   has_match_statement.stanza // 
--   has_match_statement.subject // 
--   has_match_statement.predicate // 
--   has_match_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   has_match_statement.datatype // 
--   has_match_statement.language // 
--   has_match_statement.value // 
-- has_narrow_match_statement // Autogenerated from class: has narrow match statement
--   has_narrow_match_statement.stanza // 
--   has_narrow_match_statement.subject // 
--   has_narrow_match_statement.predicate // 
--   has_narrow_match_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   has_narrow_match_statement.datatype // 
--   has_narrow_match_statement.language // 
--   has_narrow_match_statement.value // 
-- has_narrow_synonym_statement // Autogenerated from class: has narrow synonym statement
--   has_narrow_synonym_statement.stanza // 
--   has_narrow_synonym_statement.subject // 
--   has_narrow_synonym_statement.predicate // 
--   has_narrow_synonym_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   has_narrow_synonym_statement.datatype // 
--   has_narrow_synonym_statement.language // 
--   has_narrow_synonym_statement.value // 
-- has_oio_synonym_statement // Autogenerated from class: has oio synonym statement
--   has_oio_synonym_statement.stanza // 
--   has_oio_synonym_statement.subject // 
--   has_oio_synonym_statement.predicate // 
--   has_oio_synonym_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   has_oio_synonym_statement.datatype // 
--   has_oio_synonym_statement.language // 
--   has_oio_synonym_statement.value // 
-- has_related_match_statement // Autogenerated from class: has related match statement
--   has_related_match_statement.stanza // 
--   has_related_match_statement.subject // 
--   has_related_match_statement.predicate // 
--   has_related_match_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   has_related_match_statement.datatype // 
--   has_related_match_statement.language // 
--   has_related_match_statement.value // 
-- has_related_synonym_statement // Autogenerated from class: has related synonym statement
--   has_related_synonym_statement.stanza // 
--   has_related_synonym_statement.subject // 
--   has_related_synonym_statement.predicate // 
--   has_related_synonym_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   has_related_synonym_statement.datatype // 
--   has_related_synonym_statement.language // 
--   has_related_synonym_statement.value // 
-- has_synonym_statement // Autogenerated from class: has synonym statement
--   has_synonym_statement.stanza // 
--   has_synonym_statement.subject // 
--   has_synonym_statement.predicate // 
--   has_synonym_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   has_synonym_statement.datatype // 
--   has_synonym_statement.language // 
--   has_synonym_statement.value // 
-- iri_node // Autogenerated from class: iri node
--   iri_node.id // 
-- lexical_problem // a problem with the textual value of an annotation property
--   lexical_problem.subject // The thing that is problematic
--   lexical_problem.predicate // The property of the thing that is problematic
--   lexical_problem.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
-- named_individual_node // Autogenerated from class: named individual node
--   named_individual_node.id // 
-- node // Autogenerated from class: node
--   node.id // 
-- node_to_node_statement // A statement where object is non-null and value is not populated
--   node_to_node_statement.stanza // 
--   node_to_node_statement.subject // 
--   node_to_node_statement.predicate // 
--   node_to_node_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   node_to_node_statement.datatype // 
--   node_to_node_statement.language // 
--   node_to_node_statement.object // 
-- node_to_value_statement // A statement where value is non-null and object is not populated
--   node_to_value_statement.stanza // 
--   node_to_value_statement.subject // 
--   node_to_value_statement.predicate // 
--   node_to_value_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   node_to_value_statement.datatype // 
--   node_to_value_statement.language // 
--   node_to_value_statement.value // 
-- node_with_two_labels_problem // Autogenerated from class: node with two labels problem
--   node_with_two_labels_problem.subject // The thing that is problematic
--   node_with_two_labels_problem.predicate // The property of the thing that is problematic
--   node_with_two_labels_problem.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   node_with_two_labels_problem.label1 // 
--   node_with_two_labels_problem.label2 // 
-- object_property_node // Autogenerated from class: object property node
--   object_property_node.id // 
-- ontology_node // A node representing an ontology
--   ontology_node.id // 
-- ontology_status_statement // Autogenerated from class: ontology status statement
--   ontology_status_statement.stanza // 
--   ontology_status_statement.subject // 
--   ontology_status_statement.predicate // 
--   ontology_status_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   ontology_status_statement.datatype // 
--   ontology_status_statement.language // 
--   ontology_status_statement.value // 
-- owl_all_values_from // Autogenerated from class: owl all values from
--   owl_all_values_from.on_property // 
--   owl_all_values_from.filler // 
--   owl_all_values_from.id // the id of the restriction
-- owl_disjoint_class_statement // Autogenerated from class: owl disjoint class statement
--   owl_disjoint_class_statement.stanza // 
--   owl_disjoint_class_statement.predicate // 
--   owl_disjoint_class_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   owl_disjoint_class_statement.datatype // 
--   owl_disjoint_class_statement.language // 
--   owl_disjoint_class_statement.subject // One of the two classes that are disjoint. No significance to subject vs object
--   owl_disjoint_class_statement.object // One of the two classes that are disjoint. No significance to subject vs object
-- owl_equivalent_class_statement // Autogenerated from class: owl equivalent class statement
--   owl_equivalent_class_statement.stanza // 
--   owl_equivalent_class_statement.predicate // 
--   owl_equivalent_class_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   owl_equivalent_class_statement.datatype // 
--   owl_equivalent_class_statement.language // 
--   owl_equivalent_class_statement.subject // One of the two classes that are equivalent. No significance to subject vs object
--   owl_equivalent_class_statement.object // One of the two classes that are equivalent. No significance to subject vs object
-- owl_equivalent_to_intersection_member // Composition of OwlEquivalentClass, OwlIntersectionOf, and RdfListMember; C = X1 and ... and Xn
--   owl_equivalent_to_intersection_member.subject // the defined class
--   owl_equivalent_to_intersection_member.object // a class expression that forms the defining expression
-- owl_restriction // Autogenerated from class: owl restriction
--   owl_restriction.on_property // 
--   owl_restriction.filler // 
--   owl_restriction.id // the id of the restriction
-- owl_some_values_from // Autogenerated from class: owl some values from
--   owl_some_values_from.on_property // 
--   owl_some_values_from.filler // 
--   owl_some_values_from.id // the id of the restriction
-- owl_subclass_of_some_values_from // Composition of subClassOf and SomeValuesFrom
--   owl_subclass_of_some_values_from.subject // the class C in the axiom C subClassOf P some D
--   owl_subclass_of_some_values_from.predicate // the predicate P in the axiom C subClassOf P some D
--   owl_subclass_of_some_values_from.object // the class D in the axiom C subClassOf P some D
-- prefix // Maps CURIEs to URIs
--   prefix.prefix // 
--   prefix.base // 
-- problem // Represents an instance of a problem pertaining to conformance to OBO guidelines
--   problem.subject // The thing that is problematic
--   problem.predicate // The property of the thing that is problematic
--   problem.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
-- property_node // Autogenerated from class: property node
--   property_node.id // 
-- property_used_with_datatype_values_and_objects // A problem in which the same property is used two two different ways, one in which the range is a literal value, the other where it is an object.
--   property_used_with_datatype_values_and_objects.subject // The thing that is problematic
--   property_used_with_datatype_values_and_objects.predicate // The property of the thing that is problematic
--   property_used_with_datatype_values_and_objects.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
-- rdf_first_statement // A statement that connects a list to its first element. This is a low-level triple, it is unlikely you need to use this directly. It is used to define rdf_list_member_statement, which is more useful
--   rdf_first_statement.stanza // 
--   rdf_first_statement.predicate // 
--   rdf_first_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   rdf_first_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdf_first_statement.datatype // 
--   rdf_first_statement.language // 
--   rdf_first_statement.subject // The rdf:List to which the statement applies
-- rdf_level_summary_statistic // Autogenerated from class: rdf level summary statistic
--   rdf_level_summary_statistic.element // 
--   rdf_level_summary_statistic.number_of_usages // 
-- rdf_list_member_statement // Autogenerated from class: rdf list member statement
--   rdf_list_member_statement.stanza // 
--   rdf_list_member_statement.predicate // 
--   rdf_list_member_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   rdf_list_member_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdf_list_member_statement.datatype // 
--   rdf_list_member_statement.language // 
--   rdf_list_member_statement.subject // The rdf:List to which the statement applies
-- rdf_list_node // A node representing an RDF list
--   rdf_list_node.id // 
-- rdf_list_statement // A statement that is used to represent aspects of RDF lists
--   rdf_list_statement.stanza // 
--   rdf_list_statement.predicate // 
--   rdf_list_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   rdf_list_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdf_list_statement.datatype // 
--   rdf_list_statement.language // 
--   rdf_list_statement.subject // The rdf:List to which the statement applies
-- rdf_rest_statement // A statement that connects a list to its remaining elements. This is a low-level triple, it is unlikely you need to use this directly. It is used to define rdf_list_member_statement, which is more useful
--   rdf_rest_statement.stanza // 
--   rdf_rest_statement.predicate // 
--   rdf_rest_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   rdf_rest_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdf_rest_statement.datatype // 
--   rdf_rest_statement.language // 
--   rdf_rest_statement.subject // The rdf:List to which the statement applies
-- rdf_rest_transitive_statement // Autogenerated from class: rdf rest transitive statement
--   rdf_rest_transitive_statement.stanza // 
--   rdf_rest_transitive_statement.predicate // 
--   rdf_rest_transitive_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   rdf_rest_transitive_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdf_rest_transitive_statement.datatype // 
--   rdf_rest_transitive_statement.language // 
--   rdf_rest_transitive_statement.subject // The rdf:List to which the statement applies
-- rdf_type_statement // A statement that indicates the asserted type of the subject entity
--   rdf_type_statement.stanza // 
--   rdf_type_statement.subject // 
--   rdf_type_statement.predicate // 
--   rdf_type_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdf_type_statement.datatype // 
--   rdf_type_statement.language // 
--   rdf_type_statement.object // The entity type
-- rdfs_label_statement // Autogenerated from class: rdfs label statement
--   rdfs_label_statement.stanza // 
--   rdfs_label_statement.subject // 
--   rdfs_label_statement.predicate // 
--   rdfs_label_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   rdfs_label_statement.datatype // 
--   rdfs_label_statement.language // 
--   rdfs_label_statement.value // 
-- rdfs_subclass_of_named_statement // Autogenerated from class: rdfs subclass of named statement
--   rdfs_subclass_of_named_statement.stanza // 
--   rdfs_subclass_of_named_statement.predicate // 
--   rdfs_subclass_of_named_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdfs_subclass_of_named_statement.datatype // 
--   rdfs_subclass_of_named_statement.language // 
--   rdfs_subclass_of_named_statement.subject // The subclass element of the triple
--   rdfs_subclass_of_named_statement.object // The superclass element of the triple
-- rdfs_subclass_of_statement // Autogenerated from class: rdfs subclass of statement
--   rdfs_subclass_of_statement.stanza // 
--   rdfs_subclass_of_statement.predicate // 
--   rdfs_subclass_of_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdfs_subclass_of_statement.datatype // 
--   rdfs_subclass_of_statement.language // 
--   rdfs_subclass_of_statement.subject // The subclass element of the triple
--   rdfs_subclass_of_statement.object // The superclass element of the triple
-- repair_action // Represents an action that needs to be taken to repair a problem
--   repair_action.subject // The thing that is problematic
--   repair_action.description // 
-- statements // Represents an RDF triple
--   statements.stanza // 
--   statements.subject // 
--   statements.predicate // 
--   statements.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   statements.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   statements.datatype // 
--   statements.language // 
-- subgraph_edge_by_ancestor // An edge within a subgraph anchored around a set of ancestor terms
--   subgraph_edge_by_ancestor.subject // 
--   subgraph_edge_by_ancestor.predicate // 
--   subgraph_edge_by_ancestor.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   subgraph_edge_by_ancestor.anchor_object // 
--   subgraph_edge_by_ancestor.anchor_predicate // 
-- subgraph_edge_by_descendant // An edge within a subgraph anchored around a set of descendant terms
--   subgraph_edge_by_descendant.subject // 
--   subgraph_edge_by_descendant.predicate // 
--   subgraph_edge_by_descendant.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   subgraph_edge_by_descendant.anchor_object // 
--   subgraph_edge_by_descendant.anchor_predicate // 
-- trailing_whitespace_problem // Autogenerated from class: trailing whitespace problem
--   trailing_whitespace_problem.subject // The thing that is problematic
--   trailing_whitespace_problem.predicate // The property of the thing that is problematic
--   trailing_whitespace_problem.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
-- transitive_property_node // Autogenerated from class: transitive property node
--   transitive_property_node.id // 


CREATE TABLE all_problems (
	subject TEXT, 
	predicate TEXT, 
	value TEXT
);

CREATE TABLE annotation_property_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE anonymous_class_expression (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE anonymous_expression (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE anonymous_individual_expression (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE anonymous_property_expression (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE blank_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE class_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE count_of_instantiated_classes (
	element TEXT, 
	number_of_usages INTEGER
);

CREATE TABLE count_of_predicates (
	element TEXT, 
	number_of_usages INTEGER
);

CREATE TABLE edge (
	subject TEXT, 
	predicate TEXT, 
	object TEXT
);

CREATE TABLE entailed_edge (
	subject TEXT, 
	predicate TEXT, 
	object TEXT
);

CREATE TABLE has_broad_match_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE has_broad_synonym_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE has_dbxref_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE has_exact_match_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE has_exact_synonym_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE has_mapping_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE has_match_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE has_narrow_match_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE has_narrow_synonym_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE has_oio_synonym_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE has_related_match_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE has_related_synonym_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE has_synonym_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE iri_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE lexical_problem (
	subject TEXT, 
	predicate TEXT, 
	value TEXT
);

CREATE TABLE named_individual_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE node_to_node_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE node_to_value_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE node_with_two_labels_problem (
	subject TEXT, 
	predicate TEXT, 
	value TEXT, 
	label1 TEXT, 
	label2 TEXT
);

CREATE TABLE object_property_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE ontology_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE ontology_status_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE owl_all_values_from (
	on_property TEXT, 
	filler TEXT, 
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE owl_disjoint_class_statement (
	stanza TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE owl_equivalent_class_statement (
	stanza TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE owl_equivalent_to_intersection_member (
	subject TEXT, 
	object TEXT
);

CREATE TABLE owl_restriction (
	on_property TEXT, 
	filler TEXT, 
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE owl_some_values_from (
	on_property TEXT, 
	filler TEXT, 
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE owl_subclass_of_some_values_from (
	subject TEXT, 
	predicate TEXT, 
	object TEXT
);

CREATE TABLE prefix (
	prefix TEXT, 
	base TEXT
);

CREATE TABLE problem (
	subject TEXT, 
	predicate TEXT, 
	value TEXT
);

CREATE TABLE property_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE property_used_with_datatype_values_and_objects (
	subject TEXT, 
	predicate TEXT, 
	value TEXT
);

CREATE TABLE rdf_first_statement (
	stanza TEXT, 
	predicate TEXT, 
	object TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT
);

CREATE TABLE rdf_level_summary_statistic (
	element TEXT, 
	number_of_usages INTEGER
);

CREATE TABLE rdf_list_member_statement (
	stanza TEXT, 
	predicate TEXT, 
	object TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT
);

CREATE TABLE rdf_list_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE rdf_list_statement (
	stanza TEXT, 
	predicate TEXT, 
	object TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT
);

CREATE TABLE rdf_rest_statement (
	stanza TEXT, 
	predicate TEXT, 
	object TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT
);

CREATE TABLE rdf_rest_transitive_statement (
	stanza TEXT, 
	predicate TEXT, 
	object TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT
);

CREATE TABLE rdf_type_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE rdfs_label_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE rdfs_subclass_of_named_statement (
	stanza TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE rdfs_subclass_of_statement (
	stanza TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE repair_action (
	subject TEXT, 
	description TEXT
);

CREATE TABLE statements (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT
);

CREATE TABLE subgraph_edge_by_ancestor (
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	anchor_object TEXT, 
	anchor_predicate TEXT
);

CREATE TABLE subgraph_edge_by_descendant (
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	anchor_object TEXT, 
	anchor_predicate TEXT
);

CREATE TABLE trailing_whitespace_problem (
	subject TEXT, 
	predicate TEXT, 
	value TEXT
);

CREATE TABLE transitive_property_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

-- ** REWRITE TABLES AS VIEWS **
-- SCHEMA: https://w3id.org/kgcl/semsql

DROP TABLE node_to_node_statement;
CREATE VIEW node_to_node_statement AS SELECT * FROM statements WHERE object IS NOT NULL;

DROP TABLE node_to_value_statement;
CREATE VIEW node_to_value_statement AS SELECT * FROM statements WHERE value IS NOT NULL;

DROP TABLE rdf_type_statement;
CREATE VIEW rdf_type_statement AS SELECT * FROM statements WHERE predicate='rdf:type';

DROP TABLE rdfs_subclass_of_statement;
CREATE VIEW rdfs_subclass_of_statement AS SELECT * FROM statements WHERE predicate='rdfs:subClassOf';

DROP TABLE rdfs_subclass_of_named_statement;
CREATE VIEW rdfs_subclass_of_named_statement AS SELECT * FROM rdfs_subclass_of_statement WHERE object NOT LIKE '_:%';

DROP TABLE rdfs_label_statement;
CREATE VIEW rdfs_label_statement AS SELECT * FROM statements WHERE predicate='rdfs:label';

DROP TABLE rdf_first_statement;
CREATE VIEW rdf_first_statement AS SELECT * FROM statements WHERE predicate='rdf:first';

DROP TABLE rdf_rest_statement;
CREATE VIEW rdf_rest_statement AS SELECT * FROM statements WHERE predicate='rdf:rest';

DROP TABLE rdf_rest_transitive_statement;
CREATE VIEW rdf_rest_transitive_statement AS WITH RECURSIVE rdf_rest_transitive_statement
             (
                   subject, object
             )
             AS
             (SELECT subject, object
                FROM rdf_rest_statement
               UNION ALL
              SELECT
                   rest.subject, rest_t.object
                FROM rdf_rest_statement AS rest
                JOIN rdf_rest_transitive_statement AS rest_t
                  ON rest.object = rest_t.subject
             )
          SELECT * FROM rdf_rest_transitive_statement;

DROP TABLE rdf_list_member_statement;
CREATE VIEW rdf_list_member_statement AS SELECT
     rest_t.subject,
     f.object
    FROM rdf_rest_transitive_statement AS rest_t JOIN rdf_first_statement AS f ON (rest_t.object = f.subject)
    UNION
    SELECT subject,object FROM rdf_first_statement;

DROP TABLE node;
CREATE VIEW node AS SELECT distinct(subject) AS id FROM statements UNION SELECT distinct(object) AS id FROM statements WHERE datatype IS NOT NULL;

DROP TABLE blank_node;
CREATE VIEW blank_node AS SELECT * FROM node WHERE id LIKE '_:%';

DROP TABLE rdf_list_node;
CREATE VIEW rdf_list_node AS SELECT distinct subject AS id from rdf_type_statement WHERE object = 'rdf:List';

DROP TABLE iri_node;
CREATE VIEW iri_node AS SELECT * FROM node WHERE id NOT LIKE '_:%';

DROP TABLE class_node;
CREATE VIEW class_node AS SELECT distinct subject AS id from rdf_type_statement WHERE object = 'owl:Class';

DROP TABLE named_individual_node;
CREATE VIEW named_individual_node AS SELECT distinct subject AS id from rdf_type_statement WHERE object = 'owl:NamedIndividual';

DROP TABLE count_of_predicates;
CREATE VIEW count_of_predicates AS SELECT predicate AS element, count(*) AS number_of_usages FROM statements GROUP BY predicate ORDER BY number_of_usages DESC;

DROP TABLE count_of_instantiated_classes;
CREATE VIEW count_of_instantiated_classes AS SELECT object AS element, count(*) AS number_of_usages FROM rdf_type_statement GROUP BY element ORDER BY number_of_usages DESC;

DROP TABLE ontology_node;
CREATE VIEW ontology_node AS SELECT DISTINCT subject AS id FROM rdf_type_statement WHERE object='owl:Ontology';

DROP TABLE object_property_node;
CREATE VIEW object_property_node AS SELECT DISTINCT subject AS id FROM rdf_type_statement WHERE object='owl:ObjectProperty';

DROP TABLE transitive_property_node;
CREATE VIEW transitive_property_node AS SELECT DISTINCT subject AS id FROM rdf_type_statement WHERE object='owl:TransitiveProperty';

DROP TABLE annotation_property_node;
CREATE VIEW annotation_property_node AS SELECT DISTINCT subject AS id FROM rdf_type_statement WHERE object='owl:AnnotatonProperty';

DROP TABLE owl_equivalent_class_statement;
CREATE VIEW owl_equivalent_class_statement AS SELECT * FROM statements WHERE predicate='owl:equivalentClass';

DROP TABLE owl_disjoint_class_statement;
CREATE VIEW owl_disjoint_class_statement AS SELECT * FROM statements WHERE predicate='owl:disjointClass';

DROP TABLE owl_some_values_from;
CREATE VIEW owl_some_values_from AS SELECT onProperty.subject AS id,
            onProperty.object AS on_property,
            someValuesFrom.object AS filler
            FROM
       statements AS onProperty,
       statements AS someValuesFrom
     WHERE
       onProperty.predicate = 'owl:onProperty' AND
       onProperty.subject=someValuesFrom.subject AND
       someValuesFrom.predicate='owl:someValuesFrom';

DROP TABLE owl_all_values_from;
CREATE VIEW owl_all_values_from AS SELECT onProperty.subject AS id,
            onProperty.object AS on_property,
            someValuesFrom.object AS filler
            FROM
       statements AS onProperty,
       statements AS someValuesFrom
     WHERE
       onProperty.predicate = 'owl:onProperty' AND
       onProperty.subject=someValuesFrom.subject AND
       someValuesFrom.predicate='owl:allValuesFrom';

DROP TABLE owl_subclass_of_some_values_from;
CREATE VIEW owl_subclass_of_some_values_from AS SELECT subClassOf.stanza,
         subClassOf.subject,
         svf.on_property AS predicate,
         svf.filler AS object
         FROM
    statements AS subClassOf, 
    owl_some_values_from AS svf
  WHERE
    subClassOf.predicate = 'rdfs:subClassOf' AND
    svf.id=subClassOf.object;

DROP TABLE owl_equivalent_to_intersection_member;
CREATE VIEW owl_equivalent_to_intersection_member AS SELECT e.stanza,
           e.subject,
           m.object
           FROM
      owl_equivalent_class_statement AS e JOIN
      statements AS i ON (e.object=i.subject) JOIN
      rdf_list_member_statement AS m ON (i.object=m.subject)
    WHERE
      i.predicate = 'owl:intersectionOf';

DROP TABLE ontology_status_statement;
CREATE VIEW ontology_status_statement AS SELECT * FROM statements WHERE predicate = '<http://obofoundry.github.io/vocabulary/activity_status>' UNION SELECT * FROM statements WHERE predicate = 'pav:status';

DROP TABLE trailing_whitespace_problem;
CREATE VIEW trailing_whitespace_problem AS SELECT
  subject,
  predicate,
  value
FROM statements WHERE VALUE like ' %' OR VALUE like '% ';

DROP TABLE property_used_with_datatype_values_and_objects;
CREATE VIEW property_used_with_datatype_values_and_objects AS SELECT
    DISTINCT
      s1.predicate AS subject,
      s1.predicate,
      s1.datatype AS value
  FROM statements AS s1, statements AS s2 ON (s1.predicate=s2.predicate)
  WHERE s1.value IS NOT NULL and s2.object IS NOT NULL;

DROP TABLE node_with_two_labels_problem;
CREATE VIEW node_with_two_labels_problem AS SELECT
     s1.subject,
     s1.predicate,
     s1.value
  FROM rdfs_label_statement AS s1, rdfs_label_statement AS s2
  WHERE s1.subject=s2.subject AND s1.value != s2.value;

DROP TABLE all_problems;
CREATE VIEW all_problems AS SELECT * FROM node_with_two_labels_problem UNION SELECT * FROM trailing_whitespace_problem;

DROP TABLE has_exact_synonym_statement;
CREATE VIEW has_exact_synonym_statement AS SELECT * FROM statements WHERE predicate='oio:hasExactSynonym';

DROP TABLE has_broad_synonym_statement;
CREATE VIEW has_broad_synonym_statement AS SELECT * FROM statements WHERE predicate='oio:hasBroadSynonym';

DROP TABLE has_narrow_synonym_statement;
CREATE VIEW has_narrow_synonym_statement AS SELECT * FROM statements WHERE predicate='oio:hasNarrowSynonym';

DROP TABLE has_related_synonym_statement;
CREATE VIEW has_related_synonym_statement AS SELECT * FROM statements WHERE predicate='oio:hasRelatedSynonym';

DROP TABLE has_exact_match_statement;
CREATE VIEW has_exact_match_statement AS SELECT * FROM statements WHERE predicate='skos:hasExactMatch';

DROP TABLE has_broad_match_statement;
CREATE VIEW has_broad_match_statement AS SELECT * FROM statements WHERE predicate='skos:hasBroadMatch';

DROP TABLE has_narrow_match_statement;
CREATE VIEW has_narrow_match_statement AS SELECT * FROM statements WHERE predicate='skos:hasNarrowMatch';

DROP TABLE has_related_match_statement;
CREATE VIEW has_related_match_statement AS SELECT * FROM statements WHERE predicate='skos:hasRelatedMatch';

DROP TABLE has_dbxref_statement;
CREATE VIEW has_dbxref_statement AS SELECT * FROM statements WHERE predicate='oio:hasDbXref';

DROP TABLE edge;
CREATE VIEW edge AS SELECT subject, predicate, object FROM owl_subclass_of_some_values_from UNION
    SELECT subject, predicate, object FROM rdfs_subclass_of_named_statement;

DROP TABLE subgraph_edge_by_ancestor;
CREATE VIEW subgraph_edge_by_ancestor AS SELECT
    edge.*,
    ee.predicate AS anchor_predicate,
    ee.object AS anchor_object
  FROM edge JOIN entailed_edge AS ee ON (edge.subject = ee.subject);

DROP TABLE subgraph_edge_by_descendant;
CREATE VIEW subgraph_edge_by_descendant AS SELECT
    edge.*,
    ee.predicate AS anchor_predicate,
    ee.subject AS anchor_object
  FROM edge JOIN entailed_edge AS ee ON (edge.subject = ee.object);
