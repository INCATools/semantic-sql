-- annotation_property_node // Autogenerated from class: annotation property node
--   annotation_property_node.id // 
-- anonymous_class_expression // Autogenerated from class: anonymous class expression
--   anonymous_class_expression.id // 
-- anonymous_expression // Autogenerated from class: anonymous expression
--   anonymous_expression.id // 
-- anonymous_individual_expression // Autogenerated from class: anonymous individual expression
--   anonymous_individual_expression.id // 
-- anonymous_property_expression // Autogenerated from class: anonymous property expression
--   anonymous_property_expression.id // 
-- asymmetric_property_node // Autogenerated from class: asymmetric property node
--   asymmetric_property_node.id // 
-- blank_node // Autogenerated from class: blank node
--   blank_node.id // 
-- class_node // Autogenerated from class: class node
--   class_node.id // 
-- count_of_instantiated_classes // Autogenerated from class: count of instantiated classes
--   count_of_instantiated_classes.element // 
--   count_of_instantiated_classes.number_of_usages // 
-- count_of_predicates // Autogenerated from class: count of predicates
--   count_of_predicates.element // 
--   count_of_predicates.number_of_usages // 
-- deprecated_node // Autogenerated from class: deprecated node
--   deprecated_node.id // 
-- edge // A relation graph edge that connects two entities by a predicate. Note an edge is distinct from a statement, in that an axiom such as A SubClassOf R some B is represented as multiple statements, but is a single relation graph edge
--   edge.subject // 
--   edge.predicate // 
--   edge.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
-- entailed_edge // A relation graph edge that is inferred
--   entailed_edge.subject // 
--   entailed_edge.predicate // 
--   entailed_edge.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
-- iri_node // Autogenerated from class: iri node
--   iri_node.id // 
-- irreflexive_property_node // Autogenerated from class: irreflexive property node
--   irreflexive_property_node.id // 
-- named_individual_node // Autogenerated from class: named individual node
--   named_individual_node.id // 
-- node // Autogenerated from class: node
--   node.id // 
-- node_to_node_statement // A statement where object is non-null and value is not populated
--   node_to_node_statement.stanza // 
--   node_to_node_statement.subject // 
--   node_to_node_statement.predicate // 
--   node_to_node_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   node_to_node_statement.datatype // 
--   node_to_node_statement.language // 
--   node_to_node_statement.object // 
-- node_to_value_statement // A statement where value is non-null and object is not populated
--   node_to_value_statement.stanza // 
--   node_to_value_statement.subject // 
--   node_to_value_statement.predicate // 
--   node_to_value_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   node_to_value_statement.datatype // 
--   node_to_value_statement.language // 
--   node_to_value_statement.value // 
-- object_property_node // Autogenerated from class: object property node
--   object_property_node.id // 
-- ontology_node // A node representing an ontology
--   ontology_node.id // 
-- owl_all_values_from // Autogenerated from class: owl all values from
--   owl_all_values_from.on_property // 
--   owl_all_values_from.filler // 
--   owl_all_values_from.id // the id of the restriction
-- owl_axiom // Autogenerated from class: owl axiom
--   owl_axiom.stanza // 
--   owl_axiom.subject // 
--   owl_axiom.predicate // 
--   owl_axiom.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   owl_axiom.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   owl_axiom.datatype // 
--   owl_axiom.language // 
--   owl_axiom.id // 
-- owl_axiom_annotation // Autogenerated from class: owl axiom annotation
--   owl_axiom_annotation.stanza // 
--   owl_axiom_annotation.subject // 
--   owl_axiom_annotation.predicate // 
--   owl_axiom_annotation.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   owl_axiom_annotation.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   owl_axiom_annotation.datatype // 
--   owl_axiom_annotation.language // 
--   owl_axiom_annotation.axiom_predicate // 
--   owl_axiom_annotation.axiom_object // 
--   owl_axiom_annotation.axiom_value // 
--   owl_axiom_annotation.axiom_language // 
--   owl_axiom_annotation.axiom_datatype // 
-- owl_complement_of_statement // Autogenerated from class: owl complement of statement
--   owl_complement_of_statement.stanza // 
--   owl_complement_of_statement.subject // 
--   owl_complement_of_statement.predicate // 
--   owl_complement_of_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   owl_complement_of_statement.datatype // 
--   owl_complement_of_statement.language // 
--   owl_complement_of_statement.object // 
-- owl_disjoint_class_statement // Autogenerated from class: owl disjoint class statement
--   owl_disjoint_class_statement.stanza // 
--   owl_disjoint_class_statement.predicate // 
--   owl_disjoint_class_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   owl_disjoint_class_statement.datatype // 
--   owl_disjoint_class_statement.language // 
--   owl_disjoint_class_statement.subject // One of the two classes that are disjoint. No significance to subject vs object
--   owl_disjoint_class_statement.object // One of the two classes that are disjoint. No significance to subject vs object
-- owl_equivalent_class_statement // Autogenerated from class: owl equivalent class statement
--   owl_equivalent_class_statement.stanza // 
--   owl_equivalent_class_statement.predicate // 
--   owl_equivalent_class_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   owl_equivalent_class_statement.datatype // 
--   owl_equivalent_class_statement.language // 
--   owl_equivalent_class_statement.subject // One of the two classes that are equivalent. No significance to subject vs object
--   owl_equivalent_class_statement.object // One of the two classes that are equivalent. No significance to subject vs object
-- owl_equivalent_to_intersection_member // Composition of OwlEquivalentClass, OwlIntersectionOf, and RdfListMember; C = X1 and ... and Xn
--   owl_equivalent_to_intersection_member.subject // the defined class
--   owl_equivalent_to_intersection_member.object // a class expression that forms the defining expression
-- owl_has_self // Autogenerated from class: owl has self
--   owl_has_self.on_property // 
--   owl_has_self.id // the id of the restriction
--   owl_has_self.filler // This is Null for a self-restriction
-- owl_has_value // Autogenerated from class: owl has value
--   owl_has_value.on_property // 
--   owl_has_value.filler // 
--   owl_has_value.id // the id of the restriction
-- owl_imports_statement // Autogenerated from class: owl imports statement
--   owl_imports_statement.stanza // 
--   owl_imports_statement.subject // 
--   owl_imports_statement.predicate // 
--   owl_imports_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   owl_imports_statement.datatype // 
--   owl_imports_statement.language // 
--   owl_imports_statement.object // 
-- owl_inverse_of_statement // Autogenerated from class: owl inverse of statement
--   owl_inverse_of_statement.stanza // 
--   owl_inverse_of_statement.subject // 
--   owl_inverse_of_statement.predicate // 
--   owl_inverse_of_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   owl_inverse_of_statement.datatype // 
--   owl_inverse_of_statement.language // 
--   owl_inverse_of_statement.object // 
-- owl_reified_axiom // Autogenerated from class: owl reified axiom
--   owl_reified_axiom.stanza // 
--   owl_reified_axiom.subject // 
--   owl_reified_axiom.predicate // 
--   owl_reified_axiom.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   owl_reified_axiom.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   owl_reified_axiom.datatype // 
--   owl_reified_axiom.language // 
--   owl_reified_axiom.id // 
-- owl_restriction // Autogenerated from class: owl restriction
--   owl_restriction.on_property // 
--   owl_restriction.filler // 
--   owl_restriction.id // the id of the restriction
-- owl_same_as_statement // Autogenerated from class: owl same as statement
--   owl_same_as_statement.stanza // 
--   owl_same_as_statement.predicate // 
--   owl_same_as_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   owl_same_as_statement.datatype // 
--   owl_same_as_statement.language // 
--   owl_same_as_statement.subject // One of the two classes that are equivalent. No significance to subject vs object
--   owl_same_as_statement.object // One of the two classes that are equivalent. No significance to subject vs object
-- owl_some_values_from // An OWL SomeValuesFrom restriction
--   owl_some_values_from.on_property // 
--   owl_some_values_from.filler // 
--   owl_some_values_from.id // the id of the restriction
-- owl_subclass_of_some_values_from // Composition of subClassOf and SomeValuesFrom
--   owl_subclass_of_some_values_from.subject // the class C in the axiom C subClassOf P some D
--   owl_subclass_of_some_values_from.predicate // the predicate P in the axiom C subClassOf P some D
--   owl_subclass_of_some_values_from.object // the class D in the axiom C subClassOf P some D
-- prefix // Maps CURIEs to URIs
--   prefix.prefix // 
--   prefix.base // 
-- property_node // Note this only directly classifies nodes asserted to be rdf:Properties
--   property_node.id // 
-- rdf_first_statement // A statement that connects a list to its first element. This is a low-level triple, it is unlikely you need to use this directly. It is used to define rdf_list_member_statement, which is more useful
--   rdf_first_statement.stanza // 
--   rdf_first_statement.predicate // 
--   rdf_first_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   rdf_first_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdf_first_statement.datatype // 
--   rdf_first_statement.language // 
--   rdf_first_statement.subject // The rdf:List to which the statement applies
-- rdf_level_summary_statistic // Autogenerated from class: rdf level summary statistic
--   rdf_level_summary_statistic.element // 
--   rdf_level_summary_statistic.number_of_usages // 
-- rdf_list_member_statement // Autogenerated from class: rdf list member statement
--   rdf_list_member_statement.stanza // 
--   rdf_list_member_statement.predicate // 
--   rdf_list_member_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   rdf_list_member_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdf_list_member_statement.datatype // 
--   rdf_list_member_statement.language // 
--   rdf_list_member_statement.subject // The rdf:List to which the statement applies
-- rdf_list_node // A node representing an RDF list
--   rdf_list_node.id // 
-- rdf_list_statement // A statement that is used to represent aspects of RDF lists
--   rdf_list_statement.stanza // 
--   rdf_list_statement.predicate // 
--   rdf_list_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   rdf_list_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdf_list_statement.datatype // 
--   rdf_list_statement.language // 
--   rdf_list_statement.subject // The rdf:List to which the statement applies
-- rdf_rest_statement // A statement that connects a list to its remaining elements. This is a low-level triple, it is unlikely you need to use this directly. It is used to define rdf_list_member_statement, which is more useful
--   rdf_rest_statement.stanza // 
--   rdf_rest_statement.predicate // 
--   rdf_rest_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   rdf_rest_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdf_rest_statement.datatype // 
--   rdf_rest_statement.language // 
--   rdf_rest_statement.subject // The rdf:List to which the statement applies
-- rdf_rest_transitive_statement // Autogenerated from class: rdf rest transitive statement
--   rdf_rest_transitive_statement.stanza // 
--   rdf_rest_transitive_statement.predicate // 
--   rdf_rest_transitive_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   rdf_rest_transitive_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdf_rest_transitive_statement.datatype // 
--   rdf_rest_transitive_statement.language // 
--   rdf_rest_transitive_statement.subject // The rdf:List to which the statement applies
-- rdf_type_statement // A statement that indicates the asserted type of the subject entity
--   rdf_type_statement.stanza // 
--   rdf_type_statement.subject // 
--   rdf_type_statement.predicate // 
--   rdf_type_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdf_type_statement.datatype // 
--   rdf_type_statement.language // 
--   rdf_type_statement.object // The entity type
-- rdfs_domain_statement // Autogenerated from class: rdfs domain statement
--   rdfs_domain_statement.stanza // 
--   rdfs_domain_statement.subject // 
--   rdfs_domain_statement.predicate // 
--   rdfs_domain_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdfs_domain_statement.datatype // 
--   rdfs_domain_statement.language // 
--   rdfs_domain_statement.object // 
-- rdfs_label_statement // Autogenerated from class: rdfs label statement
--   rdfs_label_statement.stanza // 
--   rdfs_label_statement.subject // 
--   rdfs_label_statement.predicate // 
--   rdfs_label_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   rdfs_label_statement.datatype // 
--   rdfs_label_statement.language // 
--   rdfs_label_statement.value // The label value
-- rdfs_range_statement // Autogenerated from class: rdfs range statement
--   rdfs_range_statement.stanza // 
--   rdfs_range_statement.subject // 
--   rdfs_range_statement.predicate // 
--   rdfs_range_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdfs_range_statement.datatype // 
--   rdfs_range_statement.language // 
--   rdfs_range_statement.object // 
-- rdfs_subclass_of_named_statement // Autogenerated from class: rdfs subclass of named statement
--   rdfs_subclass_of_named_statement.stanza // 
--   rdfs_subclass_of_named_statement.predicate // 
--   rdfs_subclass_of_named_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdfs_subclass_of_named_statement.datatype // 
--   rdfs_subclass_of_named_statement.language // 
--   rdfs_subclass_of_named_statement.subject // The subclass element of the triple
--   rdfs_subclass_of_named_statement.object // The superclass element of the triple
-- rdfs_subclass_of_statement // Autogenerated from class: rdfs subclass of statement
--   rdfs_subclass_of_statement.stanza // 
--   rdfs_subclass_of_statement.predicate // 
--   rdfs_subclass_of_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdfs_subclass_of_statement.datatype // 
--   rdfs_subclass_of_statement.language // 
--   rdfs_subclass_of_statement.subject // The subclass element of the triple
--   rdfs_subclass_of_statement.object // The superclass element of the triple
-- rdfs_subproperty_of_statement // Autogenerated from class: rdfs subproperty of statement
--   rdfs_subproperty_of_statement.stanza // 
--   rdfs_subproperty_of_statement.predicate // 
--   rdfs_subproperty_of_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdfs_subproperty_of_statement.datatype // 
--   rdfs_subproperty_of_statement.language // 
--   rdfs_subproperty_of_statement.subject // The subproperty element of the triple
--   rdfs_subproperty_of_statement.object // The superproperty element of the triple
-- reflexive_property_node // Autogenerated from class: reflexive property node
--   reflexive_property_node.id // 
-- statements // Represents an RDF triple
--   statements.stanza // 
--   statements.subject // 
--   statements.predicate // 
--   statements.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   statements.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   statements.datatype // 
--   statements.language // 
-- subgraph_edge_by_ancestor // An edge within a subgraph anchored around a set of ancestor terms
--   subgraph_edge_by_ancestor.subject // 
--   subgraph_edge_by_ancestor.predicate // 
--   subgraph_edge_by_ancestor.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   subgraph_edge_by_ancestor.anchor_object // 
--   subgraph_edge_by_ancestor.anchor_predicate // 
-- subgraph_edge_by_child // An edge within a subgraph anchored around a set of child terms
--   subgraph_edge_by_child.subject // 
--   subgraph_edge_by_child.predicate // 
--   subgraph_edge_by_child.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   subgraph_edge_by_child.anchor_object // 
--   subgraph_edge_by_child.anchor_predicate // 
-- subgraph_edge_by_descendant // An edge within a subgraph anchored around a set of descendant terms
--   subgraph_edge_by_descendant.subject // 
--   subgraph_edge_by_descendant.predicate // 
--   subgraph_edge_by_descendant.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   subgraph_edge_by_descendant.anchor_object // 
--   subgraph_edge_by_descendant.anchor_predicate // 
-- subgraph_edge_by_parent // An edge within a subgraph anchored around a set of parent terms
--   subgraph_edge_by_parent.subject // 
--   subgraph_edge_by_parent.predicate // 
--   subgraph_edge_by_parent.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   subgraph_edge_by_parent.anchor_object // 
--   subgraph_edge_by_parent.anchor_predicate // 
-- subgraph_edge_by_self // A special null form of a subgraph query where there is no expansion
--   subgraph_edge_by_self.subject // 
--   subgraph_edge_by_self.predicate // 
--   subgraph_edge_by_self.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   subgraph_edge_by_self.anchor_object // 
--   subgraph_edge_by_self.anchor_predicate // 
-- subgraph_query // A subgraph query encompasses as subgraph edge and a seed/anchor object and seed/anchor predicate
--   subgraph_query.subject // subject of the subgraph edge
--   subgraph_query.predicate // predicate of the subgraph edge
--   subgraph_query.object // object of the subgraph edge
--   subgraph_query.anchor_object // The entity that is used to seed the graph. The seed entity will bear some relationship to each subgraph edge; E.g. with an ancestor subgraph query, all edges will have a subject that descends from the ancestor
--   subgraph_query.anchor_predicate // The predicate that is used to determine if an edge should be included based on relationship to the anchor_object.
-- symmetric_property_node // Autogenerated from class: symmetric property node
--   symmetric_property_node.id // 
-- transitive_property_node // Autogenerated from class: transitive property node
--   transitive_property_node.id // 


CREATE TABLE annotation_property_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE anonymous_class_expression (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE anonymous_expression (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE anonymous_individual_expression (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE anonymous_property_expression (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE asymmetric_property_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE blank_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE class_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE count_of_instantiated_classes (
	element TEXT, 
	number_of_usages INTEGER
);

CREATE TABLE count_of_predicates (
	element TEXT, 
	number_of_usages INTEGER
);

CREATE TABLE deprecated_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE edge (
	subject TEXT, 
	predicate TEXT, 
	object TEXT
);

CREATE TABLE entailed_edge (
	subject TEXT, 
	predicate TEXT, 
	object TEXT
);

CREATE TABLE iri_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE irreflexive_property_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE named_individual_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE node_to_node_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE node_to_value_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE object_property_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE ontology_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE owl_all_values_from (
	on_property TEXT, 
	filler TEXT, 
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE owl_axiom (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE owl_axiom_annotation (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	axiom_predicate TEXT, 
	axiom_object TEXT, 
	axiom_value TEXT, 
	axiom_language TEXT, 
	axiom_datatype TEXT
);

CREATE TABLE owl_complement_of_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE owl_disjoint_class_statement (
	stanza TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE owl_equivalent_class_statement (
	stanza TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE owl_equivalent_to_intersection_member (
	subject TEXT, 
	object TEXT
);

CREATE TABLE owl_has_self (
	on_property TEXT, 
	id TEXT NOT NULL, 
	filler TEXT, 
	PRIMARY KEY (id)
);

CREATE TABLE owl_has_value (
	on_property TEXT, 
	filler TEXT, 
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE owl_imports_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE owl_inverse_of_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE owl_reified_axiom (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE owl_restriction (
	on_property TEXT, 
	filler TEXT, 
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE owl_same_as_statement (
	stanza TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE owl_some_values_from (
	on_property TEXT, 
	filler TEXT, 
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE owl_subclass_of_some_values_from (
	subject TEXT, 
	predicate TEXT, 
	object TEXT
);

CREATE TABLE prefix (
	prefix TEXT, 
	base TEXT
);

CREATE TABLE property_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE rdf_first_statement (
	stanza TEXT, 
	predicate TEXT, 
	object TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT
);

CREATE TABLE rdf_level_summary_statistic (
	element TEXT, 
	number_of_usages INTEGER
);

CREATE TABLE rdf_list_member_statement (
	stanza TEXT, 
	predicate TEXT, 
	object TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT
);

CREATE TABLE rdf_list_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE rdf_list_statement (
	stanza TEXT, 
	predicate TEXT, 
	object TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT
);

CREATE TABLE rdf_rest_statement (
	stanza TEXT, 
	predicate TEXT, 
	object TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT
);

CREATE TABLE rdf_rest_transitive_statement (
	stanza TEXT, 
	predicate TEXT, 
	object TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT
);

CREATE TABLE rdf_type_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE rdfs_domain_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE rdfs_label_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE rdfs_range_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE rdfs_subclass_of_named_statement (
	stanza TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE rdfs_subclass_of_statement (
	stanza TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE rdfs_subproperty_of_statement (
	stanza TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE reflexive_property_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE statements (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT
);

CREATE TABLE subgraph_edge_by_ancestor (
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	anchor_object TEXT, 
	anchor_predicate TEXT
);

CREATE TABLE subgraph_edge_by_child (
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	anchor_object TEXT, 
	anchor_predicate TEXT
);

CREATE TABLE subgraph_edge_by_descendant (
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	anchor_object TEXT, 
	anchor_predicate TEXT
);

CREATE TABLE subgraph_edge_by_parent (
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	anchor_object TEXT, 
	anchor_predicate TEXT
);

CREATE TABLE subgraph_edge_by_self (
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	anchor_object TEXT, 
	anchor_predicate TEXT
);

CREATE TABLE subgraph_query (
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	anchor_object TEXT, 
	anchor_predicate TEXT
);

CREATE TABLE symmetric_property_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE transitive_property_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

-- ** REWRITE TABLES AS VIEWS **
-- SCHEMA: https://w3id.org/semsql/relation_graph

DROP TABLE edge;
CREATE VIEW edge AS SELECT subject, predicate, object FROM owl_subclass_of_some_values_from UNION
    SELECT subject, predicate, object FROM rdfs_subclass_of_named_statement;

DROP TABLE subgraph_edge_by_ancestor;
CREATE VIEW subgraph_edge_by_ancestor AS SELECT
    edge.*,
    ee.predicate AS anchor_predicate,
    ee.object AS anchor_object
  FROM edge JOIN entailed_edge AS ee ON (edge.subject = ee.subject);

DROP TABLE subgraph_edge_by_descendant;
CREATE VIEW subgraph_edge_by_descendant AS SELECT
    edge.*,
    ee.predicate AS anchor_predicate,
    ee.subject AS anchor_object
  FROM edge JOIN entailed_edge AS ee ON (edge.subject = ee.object);

DROP TABLE subgraph_edge_by_parent;
CREATE VIEW subgraph_edge_by_parent AS SELECT
    edge.*,
    ee.predicate AS anchor_predicate,
    ee.object AS anchor_object
  FROM edge JOIN edge AS ee ON (edge.subject = ee.subject);

DROP TABLE subgraph_edge_by_child;
CREATE VIEW subgraph_edge_by_child AS SELECT
    edge.*,
    ee.predicate AS anchor_predicate,
    ee.subject AS anchor_object
  FROM edge JOIN edge AS ee ON (edge.subject = ee.object);

DROP TABLE subgraph_edge_by_self;
CREATE VIEW subgraph_edge_by_self AS SELECT
    edge.*,
    edge.predicate AS anchor_predicate,
    edge.subject AS anchor_object
  FROM edge;

DROP TABLE node_to_node_statement;
CREATE VIEW node_to_node_statement AS SELECT * FROM statements WHERE object IS NOT NULL;

DROP TABLE node_to_value_statement;
CREATE VIEW node_to_value_statement AS SELECT * FROM statements WHERE value IS NOT NULL;

DROP TABLE rdf_type_statement;
CREATE VIEW rdf_type_statement AS SELECT * FROM statements WHERE predicate='rdf:type';

DROP TABLE rdfs_subclass_of_statement;
CREATE VIEW rdfs_subclass_of_statement AS SELECT * FROM statements WHERE predicate='rdfs:subClassOf';

DROP TABLE rdfs_subclass_of_named_statement;
CREATE VIEW rdfs_subclass_of_named_statement AS SELECT * FROM rdfs_subclass_of_statement WHERE object NOT LIKE '_:%';

DROP TABLE rdfs_subproperty_of_statement;
CREATE VIEW rdfs_subproperty_of_statement AS SELECT * FROM statements WHERE predicate='rdfs:subPropertyOf';

DROP TABLE rdfs_label_statement;
CREATE VIEW rdfs_label_statement AS SELECT * FROM statements WHERE predicate='rdfs:label';

DROP TABLE rdfs_domain_statement;
CREATE VIEW rdfs_domain_statement AS SELECT * FROM statements WHERE predicate='rdfs:domain';

DROP TABLE rdfs_range_statement;
CREATE VIEW rdfs_range_statement AS SELECT * FROM statements WHERE predicate='rdfs:range';

DROP TABLE rdf_first_statement;
CREATE VIEW rdf_first_statement AS SELECT * FROM statements WHERE predicate='rdf:first';

DROP TABLE rdf_rest_statement;
CREATE VIEW rdf_rest_statement AS SELECT * FROM statements WHERE predicate='rdf:rest';

DROP TABLE rdf_rest_transitive_statement;
CREATE VIEW rdf_rest_transitive_statement AS WITH RECURSIVE rdf_rest_transitive_statement
             (
                   subject, object
             )
             AS
             (SELECT subject, object
                FROM rdf_rest_statement
               UNION ALL
              SELECT
                   rest.subject, rest_t.object
                FROM rdf_rest_statement AS rest
                JOIN rdf_rest_transitive_statement AS rest_t
                  ON rest.object = rest_t.subject
             )
          SELECT * FROM rdf_rest_transitive_statement;

DROP TABLE rdf_list_member_statement;
CREATE VIEW rdf_list_member_statement AS SELECT
     rest_t.subject,
     f.object
    FROM rdf_rest_transitive_statement AS rest_t JOIN rdf_first_statement AS f ON (rest_t.object = f.subject)
    UNION
    SELECT subject,object FROM rdf_first_statement;

DROP TABLE node;
CREATE VIEW node AS SELECT distinct(subject) AS id FROM statements UNION SELECT distinct(object) AS id FROM statements WHERE datatype IS NOT NULL;

DROP TABLE blank_node;
CREATE VIEW blank_node AS SELECT * FROM node WHERE id LIKE '_:%';

DROP TABLE rdf_list_node;
CREATE VIEW rdf_list_node AS SELECT distinct subject AS id from rdf_type_statement WHERE object = 'rdf:List';

DROP TABLE iri_node;
CREATE VIEW iri_node AS SELECT * FROM node WHERE id NOT LIKE '_:%';

DROP TABLE class_node;
CREATE VIEW class_node AS SELECT distinct subject AS id from rdf_type_statement WHERE object = 'owl:Class';

DROP TABLE property_node;
CREATE VIEW property_node AS SELECT distinct subject AS id from rdf_type_statement WHERE object = 'owl:Property';

DROP TABLE named_individual_node;
CREATE VIEW named_individual_node AS SELECT distinct subject AS id from rdf_type_statement WHERE object = 'owl:NamedIndividual';

DROP TABLE count_of_predicates;
CREATE VIEW count_of_predicates AS SELECT predicate AS element, count(*) AS number_of_usages FROM statements GROUP BY predicate ORDER BY number_of_usages DESC;

DROP TABLE count_of_instantiated_classes;
CREATE VIEW count_of_instantiated_classes AS SELECT object AS element, count(*) AS number_of_usages FROM rdf_type_statement GROUP BY element ORDER BY number_of_usages DESC;

DROP TABLE ontology_node;
CREATE VIEW ontology_node AS SELECT DISTINCT subject AS id FROM rdf_type_statement WHERE object='owl:Ontology';

DROP TABLE object_property_node;
CREATE VIEW object_property_node AS SELECT DISTINCT subject AS id FROM rdf_type_statement WHERE object='owl:ObjectProperty';

DROP TABLE transitive_property_node;
CREATE VIEW transitive_property_node AS SELECT DISTINCT subject AS id FROM rdf_type_statement WHERE object='owl:TransitiveProperty';

DROP TABLE symmetric_property_node;
CREATE VIEW symmetric_property_node AS SELECT DISTINCT subject AS id FROM rdf_type_statement WHERE object='owl:SymmetricProperty';

DROP TABLE reflexive_property_node;
CREATE VIEW reflexive_property_node AS SELECT DISTINCT subject AS id FROM rdf_type_statement WHERE object='owl:IrreflexiveProperty';

DROP TABLE irreflexive_property_node;
CREATE VIEW irreflexive_property_node AS SELECT DISTINCT subject AS id FROM rdf_type_statement WHERE object='owl:ReflexiveProperty';

DROP TABLE asymmetric_property_node;
CREATE VIEW asymmetric_property_node AS SELECT DISTINCT subject AS id FROM rdf_type_statement WHERE object='owl:AsymmetricProperty';

DROP TABLE annotation_property_node;
CREATE VIEW annotation_property_node AS SELECT DISTINCT subject AS id FROM rdf_type_statement WHERE object='owl:AnnotatonProperty';

DROP TABLE deprecated_node;
CREATE VIEW deprecated_node AS SELECT DISTINCT subject AS id FROM statements WHERE predicate='owl:deprecated' AND value='true';

DROP TABLE owl_imports_statement;
CREATE VIEW owl_imports_statement AS SELECT * FROM statements WHERE predicate='owl:imports';

DROP TABLE owl_inverse_of_statement;
CREATE VIEW owl_inverse_of_statement AS SELECT * FROM statements WHERE predicate='owl:inverseOf';

DROP TABLE owl_complement_of_statement;
CREATE VIEW owl_complement_of_statement AS SELECT * FROM statements WHERE predicate='owl:complementOf';

DROP TABLE owl_equivalent_class_statement;
CREATE VIEW owl_equivalent_class_statement AS SELECT * FROM statements WHERE predicate='owl:equivalentClass';

DROP TABLE owl_same_as_statement;
CREATE VIEW owl_same_as_statement AS SELECT * FROM statements WHERE predicate='owl:sameAs';

DROP TABLE owl_disjoint_class_statement;
CREATE VIEW owl_disjoint_class_statement AS SELECT * FROM statements WHERE predicate='owl:disjointClass';

DROP TABLE owl_reified_axiom;
CREATE VIEW owl_reified_axiom AS SELECT axs.subject AS id, axs.stanza AS stanza, axs.object AS subject, axp.object AS predicate, axo.object AS object, axo.value AS value, axo.datatype AS datatype, axo.language AS language FROM statements AS axs, statements AS axp, statements AS axo WHERE axs.predicate = 'owl:annotatedSource' AND axp.predicate = 'owl:annotatedProperty' AND axo.predicate = 'owl:annotatedTarget' AND axs.subject = axp.subject AND axs.subject = axo.subject;

DROP TABLE owl_axiom;
CREATE VIEW owl_axiom AS SELECT * FROM owl_reified_axiom UNION SELECT NULL AS id, * FROM statements;

DROP TABLE owl_axiom_annotation;
CREATE VIEW owl_axiom_annotation AS SELECT axpv.stanza AS stanza, axs.object AS subject, axp.object AS predicate, axo.object AS object, axo.value AS value, axo.datatype AS datatype, axo.language AS language, axpv.subject AS id, axpv.predicate AS annotation_predicate, axpv.object AS annotation_iri, axpv.value AS annotation_value, axpv.language AS annotation_language, axpv.datatype AS annotation_datatype FROM statements AS axs, statements AS axp, statements AS axo, statements AS axpv WHERE axs.predicate = 'owl:annotatedSource' AND axp.predicate = 'owl:annotatedProperty' AND axo.predicate = 'owl:annotatedTarget' AND axs.subject = axpv.subject AND axp.subject = axpv.subject AND axo.subject = axpv.subject AND axpv.predicate NOT IN ('owl:annotatedSource', 'owl:annotatedProperty', 'owl:annotatedTarget', 'rdf:type');

DROP TABLE owl_some_values_from;
CREATE VIEW owl_some_values_from AS SELECT onProperty.subject AS id,
            onProperty.object AS on_property,
            f.object AS filler
            FROM
       statements AS onProperty,
       statements AS f
     WHERE
       onProperty.predicate = 'owl:onProperty' AND
       onProperty.subject=f.subject AND
       f.predicate='owl:someValuesFrom';

DROP TABLE owl_all_values_from;
CREATE VIEW owl_all_values_from AS SELECT onProperty.subject AS id,
            onProperty.object AS on_property,
            f.object AS filler
            FROM
       statements AS onProperty,
       statements AS f
     WHERE
       onProperty.predicate = 'owl:onProperty' AND
       onProperty.subject=f.subject AND
       f.predicate='owl:allValuesFrom';

DROP TABLE owl_has_value;
CREATE VIEW owl_has_value AS SELECT onProperty.subject AS id,
            onProperty.object AS on_property,
            f.object AS filler
            FROM
       statements AS onProperty,
       statements AS f
     WHERE
       onProperty.predicate = 'owl:onProperty' AND
       onProperty.subject=f.subject AND
       f.predicate='owl:hasValue';

DROP TABLE owl_has_self;
CREATE VIEW owl_has_self AS SELECT onProperty.subject AS id,
            onProperty.object AS on_property,
            f.object AS filler
            FROM
       statements AS onProperty,
       statements AS f
     WHERE
       onProperty.predicate = 'owl:onProperty' AND
       onProperty.subject=f.subject AND
       f.predicate='owl:hasSelf' AND
       f.value='true';

DROP TABLE owl_subclass_of_some_values_from;
CREATE VIEW owl_subclass_of_some_values_from AS SELECT subClassOf.stanza,
         subClassOf.subject,
         svf.on_property AS predicate,
         svf.filler AS object
         FROM
    statements AS subClassOf, 
    owl_some_values_from AS svf
  WHERE
    subClassOf.predicate = 'rdfs:subClassOf' AND
    svf.id=subClassOf.object;

DROP TABLE owl_equivalent_to_intersection_member;
CREATE VIEW owl_equivalent_to_intersection_member AS SELECT e.stanza,
           e.subject,
           m.object
           FROM
      owl_equivalent_class_statement AS e JOIN
      statements AS i ON (e.object=i.subject) JOIN
      rdf_list_member_statement AS m ON (i.object=m.subject)
    WHERE
      i.predicate = 'owl:intersectionOf';
