-- annotation_property_node // Autogenerated from class: annotation property node
--   annotation_property_node.id // 
-- anonymous_class_expression // Autogenerated from class: anonymous class expression
--   anonymous_class_expression.id // 
-- anonymous_expression // Autogenerated from class: anonymous expression
--   anonymous_expression.id // 
-- anonymous_individual_expression // Autogenerated from class: anonymous individual expression
--   anonymous_individual_expression.id // 
-- anonymous_property_expression // Autogenerated from class: anonymous property expression
--   anonymous_property_expression.id // 
-- asymmetric_property_node // Autogenerated from class: asymmetric property node
--   asymmetric_property_node.id // 
-- axiom_dbxref_annotation // Autogenerated from class: axiom dbxref annotation
--   axiom_dbxref_annotation.stanza // 
--   axiom_dbxref_annotation.subject // 
--   axiom_dbxref_annotation.predicate // 
--   axiom_dbxref_annotation.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   axiom_dbxref_annotation.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   axiom_dbxref_annotation.datatype // 
--   axiom_dbxref_annotation.language // 
--   axiom_dbxref_annotation.axiom_predicate // 
--   axiom_dbxref_annotation.axiom_object // 
--   axiom_dbxref_annotation.axiom_value // 
--   axiom_dbxref_annotation.axiom_language // 
--   axiom_dbxref_annotation.axiom_datatype // 
-- blank_node // Autogenerated from class: blank node
--   blank_node.id // 
-- class_node // Autogenerated from class: class node
--   class_node.id // 
-- count_of_instantiated_classes // Autogenerated from class: count of instantiated classes
--   count_of_instantiated_classes.element // 
--   count_of_instantiated_classes.number_of_usages // 
-- count_of_predicates // Autogenerated from class: count of predicates
--   count_of_predicates.element // 
--   count_of_predicates.number_of_usages // 
-- deprecated_node // Autogenerated from class: deprecated node
--   deprecated_node.id // 
-- has_broad_match_statement // Autogenerated from class: has broad match statement
--   has_broad_match_statement.stanza // 
--   has_broad_match_statement.subject // 
--   has_broad_match_statement.predicate // 
--   has_broad_match_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   has_broad_match_statement.datatype // 
--   has_broad_match_statement.language // 
--   has_broad_match_statement.value // 
-- has_broad_synonym_statement // Autogenerated from class: has broad synonym statement
--   has_broad_synonym_statement.stanza // 
--   has_broad_synonym_statement.subject // 
--   has_broad_synonym_statement.predicate // 
--   has_broad_synonym_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   has_broad_synonym_statement.datatype // 
--   has_broad_synonym_statement.language // 
--   has_broad_synonym_statement.value // 
-- has_dbxref_statement // Autogenerated from class: has dbxref statement
--   has_dbxref_statement.stanza // 
--   has_dbxref_statement.subject // 
--   has_dbxref_statement.predicate // 
--   has_dbxref_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   has_dbxref_statement.datatype // 
--   has_dbxref_statement.language // 
--   has_dbxref_statement.value // 
-- has_exact_match_statement // Autogenerated from class: has exact match statement
--   has_exact_match_statement.stanza // 
--   has_exact_match_statement.subject // 
--   has_exact_match_statement.predicate // 
--   has_exact_match_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   has_exact_match_statement.datatype // 
--   has_exact_match_statement.language // 
--   has_exact_match_statement.value // 
-- has_exact_synonym_statement // Autogenerated from class: has exact synonym statement
--   has_exact_synonym_statement.stanza // 
--   has_exact_synonym_statement.subject // 
--   has_exact_synonym_statement.predicate // 
--   has_exact_synonym_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   has_exact_synonym_statement.datatype // 
--   has_exact_synonym_statement.language // 
--   has_exact_synonym_statement.value // 
-- has_mapping_statement // Autogenerated from class: has mapping statement
--   has_mapping_statement.stanza // 
--   has_mapping_statement.subject // 
--   has_mapping_statement.predicate // 
--   has_mapping_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   has_mapping_statement.datatype // 
--   has_mapping_statement.language // 
--   has_mapping_statement.value // 
-- has_match_statement // Autogenerated from class: has match statement
--   has_match_statement.stanza // 
--   has_match_statement.subject // 
--   has_match_statement.predicate // 
--   has_match_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   has_match_statement.datatype // 
--   has_match_statement.language // 
--   has_match_statement.value // 
-- has_narrow_match_statement // Autogenerated from class: has narrow match statement
--   has_narrow_match_statement.stanza // 
--   has_narrow_match_statement.subject // 
--   has_narrow_match_statement.predicate // 
--   has_narrow_match_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   has_narrow_match_statement.datatype // 
--   has_narrow_match_statement.language // 
--   has_narrow_match_statement.value // 
-- has_narrow_synonym_statement // Autogenerated from class: has narrow synonym statement
--   has_narrow_synonym_statement.stanza // 
--   has_narrow_synonym_statement.subject // 
--   has_narrow_synonym_statement.predicate // 
--   has_narrow_synonym_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   has_narrow_synonym_statement.datatype // 
--   has_narrow_synonym_statement.language // 
--   has_narrow_synonym_statement.value // 
-- has_oio_synonym_statement // Autogenerated from class: has oio synonym statement
--   has_oio_synonym_statement.stanza // 
--   has_oio_synonym_statement.subject // 
--   has_oio_synonym_statement.predicate // 
--   has_oio_synonym_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   has_oio_synonym_statement.datatype // 
--   has_oio_synonym_statement.language // 
--   has_oio_synonym_statement.value // 
-- has_related_match_statement // Autogenerated from class: has related match statement
--   has_related_match_statement.stanza // 
--   has_related_match_statement.subject // 
--   has_related_match_statement.predicate // 
--   has_related_match_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   has_related_match_statement.datatype // 
--   has_related_match_statement.language // 
--   has_related_match_statement.value // 
-- has_related_synonym_statement // Autogenerated from class: has related synonym statement
--   has_related_synonym_statement.stanza // 
--   has_related_synonym_statement.subject // 
--   has_related_synonym_statement.predicate // 
--   has_related_synonym_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   has_related_synonym_statement.datatype // 
--   has_related_synonym_statement.language // 
--   has_related_synonym_statement.value // 
-- has_synonym_statement // Autogenerated from class: has synonym statement
--   has_synonym_statement.stanza // 
--   has_synonym_statement.subject // 
--   has_synonym_statement.predicate // 
--   has_synonym_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   has_synonym_statement.datatype // 
--   has_synonym_statement.language // 
--   has_synonym_statement.value // 
-- has_text_definition_statement // Autogenerated from class: has text definition statement
--   has_text_definition_statement.stanza // 
--   has_text_definition_statement.subject // 
--   has_text_definition_statement.predicate // 
--   has_text_definition_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   has_text_definition_statement.datatype // 
--   has_text_definition_statement.language // 
--   has_text_definition_statement.value // 
-- iri_node // Autogenerated from class: iri node
--   iri_node.id // 
-- irreflexive_property_node // Autogenerated from class: irreflexive property node
--   irreflexive_property_node.id // 
-- named_individual_node // Autogenerated from class: named individual node
--   named_individual_node.id // 
-- node // Autogenerated from class: node
--   node.id // 
-- node_to_node_statement // A statement where object is non-null and value is not populated
--   node_to_node_statement.stanza // 
--   node_to_node_statement.subject // 
--   node_to_node_statement.predicate // 
--   node_to_node_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   node_to_node_statement.datatype // 
--   node_to_node_statement.language // 
--   node_to_node_statement.object // 
-- node_to_value_statement // A statement where value is non-null and object is not populated
--   node_to_value_statement.stanza // 
--   node_to_value_statement.subject // 
--   node_to_value_statement.predicate // 
--   node_to_value_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   node_to_value_statement.datatype // 
--   node_to_value_statement.language // 
--   node_to_value_statement.value // 
-- object_property_node // Autogenerated from class: object property node
--   object_property_node.id // 
-- ontology_node // A node representing an ontology
--   ontology_node.id // 
-- owl_all_values_from // Autogenerated from class: owl all values from
--   owl_all_values_from.on_property // 
--   owl_all_values_from.filler // 
--   owl_all_values_from.id // the id of the restriction
-- owl_axiom_annotation // Autogenerated from class: owl axiom annotation
--   owl_axiom_annotation.stanza // 
--   owl_axiom_annotation.subject // 
--   owl_axiom_annotation.predicate // 
--   owl_axiom_annotation.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   owl_axiom_annotation.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   owl_axiom_annotation.datatype // 
--   owl_axiom_annotation.language // 
--   owl_axiom_annotation.axiom_predicate // 
--   owl_axiom_annotation.axiom_object // 
--   owl_axiom_annotation.axiom_value // 
--   owl_axiom_annotation.axiom_language // 
--   owl_axiom_annotation.axiom_datatype // 
-- owl_complement_of_statement // Autogenerated from class: owl complement of statement
--   owl_complement_of_statement.stanza // 
--   owl_complement_of_statement.subject // 
--   owl_complement_of_statement.predicate // 
--   owl_complement_of_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   owl_complement_of_statement.datatype // 
--   owl_complement_of_statement.language // 
--   owl_complement_of_statement.object // 
-- owl_disjoint_class_statement // Autogenerated from class: owl disjoint class statement
--   owl_disjoint_class_statement.stanza // 
--   owl_disjoint_class_statement.predicate // 
--   owl_disjoint_class_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   owl_disjoint_class_statement.datatype // 
--   owl_disjoint_class_statement.language // 
--   owl_disjoint_class_statement.subject // One of the two classes that are disjoint. No significance to subject vs object
--   owl_disjoint_class_statement.object // One of the two classes that are disjoint. No significance to subject vs object
-- owl_equivalent_class_statement // Autogenerated from class: owl equivalent class statement
--   owl_equivalent_class_statement.stanza // 
--   owl_equivalent_class_statement.predicate // 
--   owl_equivalent_class_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   owl_equivalent_class_statement.datatype // 
--   owl_equivalent_class_statement.language // 
--   owl_equivalent_class_statement.subject // One of the two classes that are equivalent. No significance to subject vs object
--   owl_equivalent_class_statement.object // One of the two classes that are equivalent. No significance to subject vs object
-- owl_equivalent_to_intersection_member // Composition of OwlEquivalentClass, OwlIntersectionOf, and RdfListMember; C = X1 and ... and Xn
--   owl_equivalent_to_intersection_member.subject // the defined class
--   owl_equivalent_to_intersection_member.object // a class expression that forms the defining expression
-- owl_has_self // Autogenerated from class: owl has self
--   owl_has_self.on_property // 
--   owl_has_self.id // the id of the restriction
--   owl_has_self.filler // This is Null for a self-restriction
-- owl_has_value // Autogenerated from class: owl has value
--   owl_has_value.on_property // 
--   owl_has_value.filler // 
--   owl_has_value.id // the id of the restriction
-- owl_imports_statement // Autogenerated from class: owl imports statement
--   owl_imports_statement.stanza // 
--   owl_imports_statement.subject // 
--   owl_imports_statement.predicate // 
--   owl_imports_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   owl_imports_statement.datatype // 
--   owl_imports_statement.language // 
--   owl_imports_statement.object // 
-- owl_inverse_of_statement // Autogenerated from class: owl inverse of statement
--   owl_inverse_of_statement.stanza // 
--   owl_inverse_of_statement.subject // 
--   owl_inverse_of_statement.predicate // 
--   owl_inverse_of_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   owl_inverse_of_statement.datatype // 
--   owl_inverse_of_statement.language // 
--   owl_inverse_of_statement.object // 
-- owl_restriction // Autogenerated from class: owl restriction
--   owl_restriction.on_property // 
--   owl_restriction.filler // 
--   owl_restriction.id // the id of the restriction
-- owl_same_as_statement // Autogenerated from class: owl same as statement
--   owl_same_as_statement.stanza // 
--   owl_same_as_statement.predicate // 
--   owl_same_as_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   owl_same_as_statement.datatype // 
--   owl_same_as_statement.language // 
--   owl_same_as_statement.subject // One of the two classes that are equivalent. No significance to subject vs object
--   owl_same_as_statement.object // One of the two classes that are equivalent. No significance to subject vs object
-- owl_some_values_from // An OWL SomeValuesFrom restriction
--   owl_some_values_from.on_property // 
--   owl_some_values_from.filler // 
--   owl_some_values_from.id // the id of the restriction
-- owl_subclass_of_some_values_from // Composition of subClassOf and SomeValuesFrom
--   owl_subclass_of_some_values_from.subject // the class C in the axiom C subClassOf P some D
--   owl_subclass_of_some_values_from.predicate // the predicate P in the axiom C subClassOf P some D
--   owl_subclass_of_some_values_from.object // the class D in the axiom C subClassOf P some D
-- prefix // Maps CURIEs to URIs
--   prefix.prefix // 
--   prefix.base // 
-- property_node // Note this only directly classifies nodes asserted to be rdf:Properties
--   property_node.id // 
-- rdf_first_statement // A statement that connects a list to its first element. This is a low-level triple, it is unlikely you need to use this directly. It is used to define rdf_list_member_statement, which is more useful
--   rdf_first_statement.stanza // 
--   rdf_first_statement.predicate // 
--   rdf_first_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   rdf_first_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdf_first_statement.datatype // 
--   rdf_first_statement.language // 
--   rdf_first_statement.subject // The rdf:List to which the statement applies
-- rdf_level_summary_statistic // Autogenerated from class: rdf level summary statistic
--   rdf_level_summary_statistic.element // 
--   rdf_level_summary_statistic.number_of_usages // 
-- rdf_list_member_statement // Autogenerated from class: rdf list member statement
--   rdf_list_member_statement.stanza // 
--   rdf_list_member_statement.predicate // 
--   rdf_list_member_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   rdf_list_member_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdf_list_member_statement.datatype // 
--   rdf_list_member_statement.language // 
--   rdf_list_member_statement.subject // The rdf:List to which the statement applies
-- rdf_list_node // A node representing an RDF list
--   rdf_list_node.id // 
-- rdf_list_statement // A statement that is used to represent aspects of RDF lists
--   rdf_list_statement.stanza // 
--   rdf_list_statement.predicate // 
--   rdf_list_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   rdf_list_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdf_list_statement.datatype // 
--   rdf_list_statement.language // 
--   rdf_list_statement.subject // The rdf:List to which the statement applies
-- rdf_rest_statement // A statement that connects a list to its remaining elements. This is a low-level triple, it is unlikely you need to use this directly. It is used to define rdf_list_member_statement, which is more useful
--   rdf_rest_statement.stanza // 
--   rdf_rest_statement.predicate // 
--   rdf_rest_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   rdf_rest_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdf_rest_statement.datatype // 
--   rdf_rest_statement.language // 
--   rdf_rest_statement.subject // The rdf:List to which the statement applies
-- rdf_rest_transitive_statement // Autogenerated from class: rdf rest transitive statement
--   rdf_rest_transitive_statement.stanza // 
--   rdf_rest_transitive_statement.predicate // 
--   rdf_rest_transitive_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   rdf_rest_transitive_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdf_rest_transitive_statement.datatype // 
--   rdf_rest_transitive_statement.language // 
--   rdf_rest_transitive_statement.subject // The rdf:List to which the statement applies
-- rdf_type_statement // A statement that indicates the asserted type of the subject entity
--   rdf_type_statement.stanza // 
--   rdf_type_statement.subject // 
--   rdf_type_statement.predicate // 
--   rdf_type_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdf_type_statement.datatype // 
--   rdf_type_statement.language // 
--   rdf_type_statement.object // The entity type
-- rdfs_domain_statement // Autogenerated from class: rdfs domain statement
--   rdfs_domain_statement.stanza // 
--   rdfs_domain_statement.subject // 
--   rdfs_domain_statement.predicate // 
--   rdfs_domain_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdfs_domain_statement.datatype // 
--   rdfs_domain_statement.language // 
--   rdfs_domain_statement.object // 
-- rdfs_label_statement // Autogenerated from class: rdfs label statement
--   rdfs_label_statement.stanza // 
--   rdfs_label_statement.subject // 
--   rdfs_label_statement.predicate // 
--   rdfs_label_statement.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   rdfs_label_statement.datatype // 
--   rdfs_label_statement.language // 
--   rdfs_label_statement.value // The label value
-- rdfs_range_statement // Autogenerated from class: rdfs range statement
--   rdfs_range_statement.stanza // 
--   rdfs_range_statement.subject // 
--   rdfs_range_statement.predicate // 
--   rdfs_range_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdfs_range_statement.datatype // 
--   rdfs_range_statement.language // 
--   rdfs_range_statement.object // 
-- rdfs_subclass_of_named_statement // Autogenerated from class: rdfs subclass of named statement
--   rdfs_subclass_of_named_statement.stanza // 
--   rdfs_subclass_of_named_statement.predicate // 
--   rdfs_subclass_of_named_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdfs_subclass_of_named_statement.datatype // 
--   rdfs_subclass_of_named_statement.language // 
--   rdfs_subclass_of_named_statement.subject // The subclass element of the triple
--   rdfs_subclass_of_named_statement.object // The superclass element of the triple
-- rdfs_subclass_of_statement // Autogenerated from class: rdfs subclass of statement
--   rdfs_subclass_of_statement.stanza // 
--   rdfs_subclass_of_statement.predicate // 
--   rdfs_subclass_of_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdfs_subclass_of_statement.datatype // 
--   rdfs_subclass_of_statement.language // 
--   rdfs_subclass_of_statement.subject // The subclass element of the triple
--   rdfs_subclass_of_statement.object // The superclass element of the triple
-- rdfs_subproperty_of_statement // Autogenerated from class: rdfs subproperty of statement
--   rdfs_subproperty_of_statement.stanza // 
--   rdfs_subproperty_of_statement.predicate // 
--   rdfs_subproperty_of_statement.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   rdfs_subproperty_of_statement.datatype // 
--   rdfs_subproperty_of_statement.language // 
--   rdfs_subproperty_of_statement.subject // The subproperty element of the triple
--   rdfs_subproperty_of_statement.object // The superproperty element of the triple
-- reflexive_property_node // Autogenerated from class: reflexive property node
--   reflexive_property_node.id // 
-- statements // Represents an RDF triple
--   statements.stanza // 
--   statements.subject // 
--   statements.predicate // 
--   statements.object // Note the range of this slot is always a node. If the triple represents a literal, instead value will be populated
--   statements.value // Note the range of this slot is always a string. Only used the triple represents a literal assertion
--   statements.datatype // 
--   statements.language // 
-- symmetric_property_node // Autogenerated from class: symmetric property node
--   symmetric_property_node.id // 
-- transitive_property_node // Autogenerated from class: transitive property node
--   transitive_property_node.id // 


CREATE TABLE annotation_property_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE anonymous_class_expression (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE anonymous_expression (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE anonymous_individual_expression (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE anonymous_property_expression (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE asymmetric_property_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE axiom_dbxref_annotation (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	axiom_predicate TEXT, 
	axiom_object TEXT, 
	axiom_value TEXT, 
	axiom_language TEXT, 
	axiom_datatype TEXT
);

CREATE TABLE blank_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE class_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE count_of_instantiated_classes (
	element TEXT, 
	number_of_usages INTEGER
);

CREATE TABLE count_of_predicates (
	element TEXT, 
	number_of_usages INTEGER
);

CREATE TABLE deprecated_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE has_broad_match_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE has_broad_synonym_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE has_dbxref_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE has_exact_match_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE has_exact_synonym_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE has_mapping_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE has_match_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE has_narrow_match_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE has_narrow_synonym_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE has_oio_synonym_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE has_related_match_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE has_related_synonym_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE has_synonym_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE has_text_definition_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE iri_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE irreflexive_property_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE named_individual_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE node_to_node_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE node_to_value_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE object_property_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE ontology_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE owl_all_values_from (
	on_property TEXT, 
	filler TEXT, 
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE owl_axiom_annotation (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	axiom_predicate TEXT, 
	axiom_object TEXT, 
	axiom_value TEXT, 
	axiom_language TEXT, 
	axiom_datatype TEXT
);

CREATE TABLE owl_complement_of_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE owl_disjoint_class_statement (
	stanza TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE owl_equivalent_class_statement (
	stanza TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE owl_equivalent_to_intersection_member (
	subject TEXT, 
	object TEXT
);

CREATE TABLE owl_has_self (
	on_property TEXT, 
	id TEXT NOT NULL, 
	filler TEXT, 
	PRIMARY KEY (id)
);

CREATE TABLE owl_has_value (
	on_property TEXT, 
	filler TEXT, 
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE owl_imports_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE owl_inverse_of_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE owl_restriction (
	on_property TEXT, 
	filler TEXT, 
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE owl_same_as_statement (
	stanza TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE owl_some_values_from (
	on_property TEXT, 
	filler TEXT, 
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE owl_subclass_of_some_values_from (
	subject TEXT, 
	predicate TEXT, 
	object TEXT
);

CREATE TABLE prefix (
	prefix TEXT, 
	base TEXT
);

CREATE TABLE property_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE rdf_first_statement (
	stanza TEXT, 
	predicate TEXT, 
	object TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT
);

CREATE TABLE rdf_level_summary_statistic (
	element TEXT, 
	number_of_usages INTEGER
);

CREATE TABLE rdf_list_member_statement (
	stanza TEXT, 
	predicate TEXT, 
	object TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT
);

CREATE TABLE rdf_list_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE rdf_list_statement (
	stanza TEXT, 
	predicate TEXT, 
	object TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT
);

CREATE TABLE rdf_rest_statement (
	stanza TEXT, 
	predicate TEXT, 
	object TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT
);

CREATE TABLE rdf_rest_transitive_statement (
	stanza TEXT, 
	predicate TEXT, 
	object TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT
);

CREATE TABLE rdf_type_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE rdfs_domain_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE rdfs_label_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	datatype TEXT, 
	language TEXT, 
	value TEXT NOT NULL
);

CREATE TABLE rdfs_range_statement (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE rdfs_subclass_of_named_statement (
	stanza TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE rdfs_subclass_of_statement (
	stanza TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE rdfs_subproperty_of_statement (
	stanza TEXT, 
	predicate TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT, 
	subject TEXT, 
	object TEXT NOT NULL
);

CREATE TABLE reflexive_property_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE statements (
	stanza TEXT, 
	subject TEXT, 
	predicate TEXT, 
	object TEXT, 
	value TEXT, 
	datatype TEXT, 
	language TEXT
);

CREATE TABLE symmetric_property_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

CREATE TABLE transitive_property_node (
	id TEXT NOT NULL, 
	PRIMARY KEY (id)
);

-- ** REWRITE TABLES AS VIEWS **
-- SCHEMA: https://w3id.org/semsql/omo

DROP TABLE has_text_definition_statement;
CREATE VIEW has_text_definition_statement AS SELECT * FROM statements WHERE predicate='IAO:0000115';

DROP TABLE has_exact_synonym_statement;
CREATE VIEW has_exact_synonym_statement AS SELECT * FROM statements WHERE predicate='oio:hasExactSynonym';

DROP TABLE has_broad_synonym_statement;
CREATE VIEW has_broad_synonym_statement AS SELECT * FROM statements WHERE predicate='oio:hasBroadSynonym';

DROP TABLE has_narrow_synonym_statement;
CREATE VIEW has_narrow_synonym_statement AS SELECT * FROM statements WHERE predicate='oio:hasNarrowSynonym';

DROP TABLE has_related_synonym_statement;
CREATE VIEW has_related_synonym_statement AS SELECT * FROM statements WHERE predicate='oio:hasRelatedSynonym';

DROP TABLE has_exact_match_statement;
CREATE VIEW has_exact_match_statement AS SELECT * FROM statements WHERE predicate='skos:hasExactMatch';

DROP TABLE has_broad_match_statement;
CREATE VIEW has_broad_match_statement AS SELECT * FROM statements WHERE predicate='skos:hasBroadMatch';

DROP TABLE has_narrow_match_statement;
CREATE VIEW has_narrow_match_statement AS SELECT * FROM statements WHERE predicate='skos:hasNarrowMatch';

DROP TABLE has_related_match_statement;
CREATE VIEW has_related_match_statement AS SELECT * FROM statements WHERE predicate='skos:hasRelatedMatch';

DROP TABLE has_dbxref_statement;
CREATE VIEW has_dbxref_statement AS SELECT * FROM statements WHERE predicate='oio:hasDbXref';

DROP TABLE axiom_dbxref_annotation;
CREATE VIEW axiom_dbxref_annotation AS SELECT * FROM owl_axiom_annotation WHERE annotation_predicate = 'oio:hasDbXref';

DROP TABLE node_to_node_statement;
CREATE VIEW node_to_node_statement AS SELECT * FROM statements WHERE object IS NOT NULL;

DROP TABLE node_to_value_statement;
CREATE VIEW node_to_value_statement AS SELECT * FROM statements WHERE value IS NOT NULL;

DROP TABLE rdf_type_statement;
CREATE VIEW rdf_type_statement AS SELECT * FROM statements WHERE predicate='rdf:type';

DROP TABLE rdfs_subclass_of_statement;
CREATE VIEW rdfs_subclass_of_statement AS SELECT * FROM statements WHERE predicate='rdfs:subClassOf';

DROP TABLE rdfs_subclass_of_named_statement;
CREATE VIEW rdfs_subclass_of_named_statement AS SELECT * FROM rdfs_subclass_of_statement WHERE object NOT LIKE '_:%';

DROP TABLE rdfs_subproperty_of_statement;
CREATE VIEW rdfs_subproperty_of_statement AS SELECT * FROM statements WHERE predicate='rdfs:subPropertyOf';

DROP TABLE rdfs_label_statement;
CREATE VIEW rdfs_label_statement AS SELECT * FROM statements WHERE predicate='rdfs:label';

DROP TABLE rdfs_domain_statement;
CREATE VIEW rdfs_domain_statement AS SELECT * FROM statements WHERE predicate='rdfs:domain';

DROP TABLE rdfs_range_statement;
CREATE VIEW rdfs_range_statement AS SELECT * FROM statements WHERE predicate='rdfs:range';

DROP TABLE rdf_first_statement;
CREATE VIEW rdf_first_statement AS SELECT * FROM statements WHERE predicate='rdf:first';

DROP TABLE rdf_rest_statement;
CREATE VIEW rdf_rest_statement AS SELECT * FROM statements WHERE predicate='rdf:rest';

DROP TABLE rdf_rest_transitive_statement;
CREATE VIEW rdf_rest_transitive_statement AS WITH RECURSIVE rdf_rest_transitive_statement
             (
                   subject, object
             )
             AS
             (SELECT subject, object
                FROM rdf_rest_statement
               UNION ALL
              SELECT
                   rest.subject, rest_t.object
                FROM rdf_rest_statement AS rest
                JOIN rdf_rest_transitive_statement AS rest_t
                  ON rest.object = rest_t.subject
             )
          SELECT * FROM rdf_rest_transitive_statement;

DROP TABLE rdf_list_member_statement;
CREATE VIEW rdf_list_member_statement AS SELECT
     rest_t.subject,
     f.object
    FROM rdf_rest_transitive_statement AS rest_t JOIN rdf_first_statement AS f ON (rest_t.object = f.subject)
    UNION
    SELECT subject,object FROM rdf_first_statement;

DROP TABLE node;
CREATE VIEW node AS SELECT distinct(subject) AS id FROM statements UNION SELECT distinct(object) AS id FROM statements WHERE datatype IS NOT NULL;

DROP TABLE blank_node;
CREATE VIEW blank_node AS SELECT * FROM node WHERE id LIKE '_:%';

DROP TABLE rdf_list_node;
CREATE VIEW rdf_list_node AS SELECT distinct subject AS id from rdf_type_statement WHERE object = 'rdf:List';

DROP TABLE iri_node;
CREATE VIEW iri_node AS SELECT * FROM node WHERE id NOT LIKE '_:%';

DROP TABLE class_node;
CREATE VIEW class_node AS SELECT distinct subject AS id from rdf_type_statement WHERE object = 'owl:Class';

DROP TABLE property_node;
CREATE VIEW property_node AS SELECT distinct subject AS id from rdf_type_statement WHERE object = 'owl:Property';

DROP TABLE named_individual_node;
CREATE VIEW named_individual_node AS SELECT distinct subject AS id from rdf_type_statement WHERE object = 'owl:NamedIndividual';

DROP TABLE count_of_predicates;
CREATE VIEW count_of_predicates AS SELECT predicate AS element, count(*) AS number_of_usages FROM statements GROUP BY predicate ORDER BY number_of_usages DESC;

DROP TABLE count_of_instantiated_classes;
CREATE VIEW count_of_instantiated_classes AS SELECT object AS element, count(*) AS number_of_usages FROM rdf_type_statement GROUP BY element ORDER BY number_of_usages DESC;

DROP TABLE ontology_node;
CREATE VIEW ontology_node AS SELECT DISTINCT subject AS id FROM rdf_type_statement WHERE object='owl:Ontology';

DROP TABLE object_property_node;
CREATE VIEW object_property_node AS SELECT DISTINCT subject AS id FROM rdf_type_statement WHERE object='owl:ObjectProperty';

DROP TABLE transitive_property_node;
CREATE VIEW transitive_property_node AS SELECT DISTINCT subject AS id FROM rdf_type_statement WHERE object='owl:TransitiveProperty';

DROP TABLE symmetric_property_node;
CREATE VIEW symmetric_property_node AS SELECT DISTINCT subject AS id FROM rdf_type_statement WHERE object='owl:SymmetricProperty';

DROP TABLE reflexive_property_node;
CREATE VIEW reflexive_property_node AS SELECT DISTINCT subject AS id FROM rdf_type_statement WHERE object='owl:IrreflexiveProperty';

DROP TABLE irreflexive_property_node;
CREATE VIEW irreflexive_property_node AS SELECT DISTINCT subject AS id FROM rdf_type_statement WHERE object='owl:ReflexiveProperty';

DROP TABLE asymmetric_property_node;
CREATE VIEW asymmetric_property_node AS SELECT DISTINCT subject AS id FROM rdf_type_statement WHERE object='owl:AsymmetricProperty';

DROP TABLE annotation_property_node;
CREATE VIEW annotation_property_node AS SELECT DISTINCT subject AS id FROM rdf_type_statement WHERE object='owl:AnnotatonProperty';

DROP TABLE deprecated_node;
CREATE VIEW deprecated_node AS SELECT DISTINCT subject AS id FROM statements WHERE predicate='owl:deprecated' AND value='true';

DROP TABLE owl_imports_statement;
CREATE VIEW owl_imports_statement AS SELECT * FROM statements WHERE predicate='owl:imports';

DROP TABLE owl_inverse_of_statement;
CREATE VIEW owl_inverse_of_statement AS SELECT * FROM statements WHERE predicate='owl:inverseOf';

DROP TABLE owl_complement_of_statement;
CREATE VIEW owl_complement_of_statement AS SELECT * FROM statements WHERE predicate='owl:complementOf';

DROP TABLE owl_equivalent_class_statement;
CREATE VIEW owl_equivalent_class_statement AS SELECT * FROM statements WHERE predicate='owl:equivalentClass';

DROP TABLE owl_same_as_statement;
CREATE VIEW owl_same_as_statement AS SELECT * FROM statements WHERE predicate='owl:sameAs';

DROP TABLE owl_disjoint_class_statement;
CREATE VIEW owl_disjoint_class_statement AS SELECT * FROM statements WHERE predicate='owl:disjointClass';

DROP TABLE owl_axiom_annotation;
CREATE VIEW owl_axiom_annotation AS SELECT axpv.stanza AS stanza, axs.object AS subject, axp.object AS predicate, axo.object AS object, axo.value AS value, axo.datatype AS datatype, axo.language AS language, axpv.subject AS id, axpv.predicate AS annotation_predicate, axpv.object AS annotation_iri, axpv.value AS annotation_value, axpv.language AS annotation_language, axpv.datatype AS annotation_datatype FROM statements AS axs, statements AS axp, statements AS axo, statements AS axpv WHERE axs.predicate = 'owl:annotatedSource' AND axp.predicate = 'owl:annotatedProperty' AND axo.predicate = 'owl:annotatedTarget' AND axs.subject = axpv.subject AND axp.subject = axpv.subject AND axo.subject = axpv.subject AND axpv.predicate NOT IN ('owl:annotatedSource', 'owl:annotatedProperty', 'owl:annotatedTarget', 'rdf:type');

DROP TABLE owl_some_values_from;
CREATE VIEW owl_some_values_from AS SELECT onProperty.subject AS id,
            onProperty.object AS on_property,
            f.object AS filler
            FROM
       statements AS onProperty,
       statements AS f
     WHERE
       onProperty.predicate = 'owl:onProperty' AND
       onProperty.subject=f.subject AND
       f.predicate='owl:someValuesFrom';

DROP TABLE owl_all_values_from;
CREATE VIEW owl_all_values_from AS SELECT onProperty.subject AS id,
            onProperty.object AS on_property,
            f.object AS filler
            FROM
       statements AS onProperty,
       statements AS f
     WHERE
       onProperty.predicate = 'owl:onProperty' AND
       onProperty.subject=f.subject AND
       f.predicate='owl:allValuesFrom';

DROP TABLE owl_has_value;
CREATE VIEW owl_has_value AS SELECT onProperty.subject AS id,
            onProperty.object AS on_property,
            f.object AS filler
            FROM
       statements AS onProperty,
       statements AS f
     WHERE
       onProperty.predicate = 'owl:onProperty' AND
       onProperty.subject=f.subject AND
       f.predicate='owl:hasValue';

DROP TABLE owl_has_self;
CREATE VIEW owl_has_self AS SELECT onProperty.subject AS id,
            onProperty.object AS on_property,
            f.object AS filler
            FROM
       statements AS onProperty,
       statements AS f
     WHERE
       onProperty.predicate = 'owl:onProperty' AND
       onProperty.subject=f.subject AND
       f.predicate='owl:hasSelf' AND
       f.value='true';

DROP TABLE owl_subclass_of_some_values_from;
CREATE VIEW owl_subclass_of_some_values_from AS SELECT subClassOf.stanza,
         subClassOf.subject,
         svf.on_property AS predicate,
         svf.filler AS object
         FROM
    statements AS subClassOf, 
    owl_some_values_from AS svf
  WHERE
    subClassOf.predicate = 'rdfs:subClassOf' AND
    svf.id=subClassOf.object;

DROP TABLE owl_equivalent_to_intersection_member;
CREATE VIEW owl_equivalent_to_intersection_member AS SELECT e.stanza,
           e.subject,
           m.object
           FROM
      owl_equivalent_class_statement AS e JOIN
      statements AS i ON (e.object=i.subject) JOIN
      rdf_list_member_statement AS m ON (i.object=m.subject)
    WHERE
      i.predicate = 'owl:intersectionOf';
